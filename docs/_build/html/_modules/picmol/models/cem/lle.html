<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../../genindex.html" /><link rel="search" title="Search" href="../../../../search.html" />

    <!-- Generated with Sphinx 8.1.3 and Furo 2024.08.06 -->
        <title>picmol.models.cem.lle - picmol 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo-extensions.css?v=302659d7" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --color-brand-primary: #6851ff;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --color-brand-primary: #a08cff;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --color-brand-primary: #a08cff;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>

<div class="announcement">
  <aside class="announcement-content">
     Check out our latest release! 
  </aside>
</div>

<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../../index.html"><div class="brand">picmol 0.0.1 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../../index.html">
  
  
  <span class="sidebar-brand-text">picmol 0.0.1 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">API Reference:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../picmol.get_molecular_properties.html">Molecular Properties (picmol.get_molecular_properties)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../picmol.kbi.html">Kirkwood-Buff Integral Analysis (picmol.kbi)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../picmol.thermo_model.html">Liquid-Liquid Equilibria (picmol.thermo_model)</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../../picmol.models.html">Thermodynamic Models (picmol.models)</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Thermodynamic Models (picmol.models)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../picmol.models.numerical.html">Numerical (picmol.models.numerical)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../picmol.models.fh.html">Flory-Huggins (picmol.models.fh)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../picmol.models.nrtl.html">NRTL (picmol.models.nrtl)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../picmol.models.uniquac.html">UNIQUAC (picmol.models.uniquac)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../picmol.models.unifac.html">UNIFAC (picmol.models.unifac)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../picmol.models.unifac_subgroups.fragmentation.html">Molecule Fragmentation (picmol.models.unifac_subgroups.fragmentation)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../picmol.models.cem.html">Convex Envelope Method (picmol.models.cem)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../picmol.plotter.html">Plotting Functions (picmol.plotter)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../examples/01_kbi_analysis.html">01_comparing_KBI_correction_methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../examples/02_thermo_models.html">02_themodynamic_model_analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../examples/03_combined_kbi_thermo_analysis.html">03_combined_kbi_thermo_analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../examples/04_unifac_lle.html">04_UNIFAC_LLE_calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../examples/05_unifac_Tc_search.html">05_UNIFAC_Tc_search</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <h1>Source code for picmol.models.cem.lle</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">spat</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>



<div class="viewcode-block" id="MiscibilityGapSimplex">
<a class="viewcode-back" href="../../../../picmol.models.cem.html#picmol.models.cem.lle.MiscibilityGapSimplex">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MiscibilityGapSimplex</span><span class="p">:</span>
<span class="w">  </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Stores a simplex containing points that split into multiple liquid phases.</span>

<span class="sd">  This class represents a simplex in the composition space where liquid-liquid</span>
<span class="sd">  phase separation occurs. It stores the geometric and compositional</span>
<span class="sd">  information of the simplex, along with data about the phase split. This allows</span>
<span class="sd">  the class to be used to define a unit operation.</span>

<span class="sd">  A simplex of dimension n has :math:`N = n + 1` vertices. Edges are classified as</span>
<span class="sd">  homogeneous (between neighboring points) or heterogeneous (between</span>
<span class="sd">  non-neighboring points, indicating a phase split). &quot;Neighboring points&quot;</span>
<span class="sd">  are defined as two points contained within the same subsimplex from the</span>
<span class="sd">  discretization.</span>

<span class="sd">  :param points_coords_cart:</span>
<span class="sd">      A numpy array containing the Cartesian coordinates of the simplex vertices.</span>
<span class="sd">      Shape: (N, n), where N is the number of vertices (n+1) and n is the</span>
<span class="sd">      dimension of the simplex.</span>
<span class="sd">  :type points_coords_cart: numpy.ndarray</span>
<span class="sd">  :param points_mfr:</span>
<span class="sd">      A numpy array containing the molar fractions (barycentric coordinates) of</span>
<span class="sd">      the simplex vertices. Shape: (N, n+1).</span>
<span class="sd">  :type points_mfr: numpy.ndarray</span>
<span class="sd">  :param points_ind:</span>
<span class="sd">      A numpy array containing the indices of the simplex vertices within the</span>
<span class="sd">      original discretization. Shape: (N,).</span>
<span class="sd">  :type points_ind: numpy.ndarray</span>
<span class="sd">  :param matrix:</span>
<span class="sd">      A matrix used to transform molar fractions (barycentric coordinates) to</span>
<span class="sd">      a combined vector of ones and cartesian coordinates.  Shape: (n+1, n+1).</span>
<span class="sd">  :type matrix: numpy.ndarray</span>
<span class="sd">  :param matrix_inv:</span>
<span class="sd">      The inverse of the `matrix`.  Shape: (n+1, n+1).</span>
<span class="sd">  :type matrix_inv: numpy.ndarray</span>

<span class="sd">  :ivar index:</span>
<span class="sd">      An optional index for this simplex. Defaults to None.</span>
<span class="sd">  :vartype index: int, optional</span>
<span class="sd">  :ivar points_coordinates_cart:</span>
<span class="sd">      The Cartesian coordinates of the simplex vertices.</span>
<span class="sd">  :vartype points_coordinates_cart: numpy.ndarray</span>
<span class="sd">  :ivar points_molar_fractions:</span>
<span class="sd">      The molar fractions of the simplex vertices.</span>
<span class="sd">  :vartype points_molar_fractions: numpy.ndarray</span>
<span class="sd">  :ivar points_indices:</span>
<span class="sd">      The indices of the simplex vertices in the original discretization.</span>
<span class="sd">  :vartype points_indices: numpy.ndarray</span>
<span class="sd">  :ivar matrix:</span>
<span class="sd">      The transformation matrix from molar fractions to Cartesian coordinates.</span>
<span class="sd">  :vartype matrix: numpy.ndarray</span>
<span class="sd">  :ivar matrix_inv:</span>
<span class="sd">      The inverse of the transformation matrix.</span>
<span class="sd">  :vartype matrix_inv: numpy.ndarray</span>
<span class="sd">  :ivar edge_classification:</span>
<span class="sd">      A symmetric N x N matrix.  `edge_classification[i][j] == 1` indicates</span>
<span class="sd">      that the edge between vertex i and vertex j is heterogeneous</span>
<span class="sd">      (i.e., the points are in different phases).  Initialized to a matrix of</span>
<span class="sd">      zeros (all edges homogeneous).</span>
<span class="sd">  :vartype edge_classification: numpy.ndarray</span>
<span class="sd">  :ivar phase_blocks:</span>
<span class="sd">      A list of lists.  Each inner list contains the indices (0 to N-1) of</span>
<span class="sd">      the vertices that form the basis of a single liquid phase.  The order</span>
<span class="sd">      of phases in this list is fixed.</span>
<span class="sd">  :vartype phase_blocks: list[list[int]]</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points_coords_cart</span><span class="p">,</span> <span class="n">points_mfr</span><span class="p">,</span> <span class="n">points_ind</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">matrix_inv</span><span class="p">):</span>
    
    <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">points_coordinates_cart</span> <span class="o">=</span> <span class="n">points_coords_cart</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">points_molar_fractions</span> <span class="o">=</span> <span class="n">points_mfr</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">points_indices</span> <span class="o">=</span> <span class="n">points_ind</span>  <span class="c1"># point indices from the simplex discretization</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">matrix</span>  <span class="c1"># matrix * lambda = (1, p), lambda barycentric coordinates</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">matrix_inv</span> <span class="o">=</span> <span class="n">matrix_inv</span>

    <span class="c1"># symmetric N x N matrix, entry[i][j] == 1 means that the edge from point[i] to point [j]</span>
    <span class="c1"># is heterogeneous, matrix is filled afterwards (default is a homogeneous simplex without</span>
    <span class="c1"># an occurring phase split).</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">edge_classification</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points_indices</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points_indices</span><span class="p">)))</span>

    <span class="c1"># for each phase, we append an block = [indices], where indices refers to the point indices</span>
    <span class="c1"># which form the basis of the respective phase. the order here is the fixed order of the phases</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">phase_blocks</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the indices in here range from 0 to N-1</span>

<div class="viewcode-block" id="MiscibilityGapSimplex.get_middle">
<a class="viewcode-back" href="../../../../picmol.models.cem.html#picmol.models.cem.lle.MiscibilityGapSimplex.get_middle">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">get_middle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the composition at the center of the simplex.</span>

<span class="sd">    This method computes the average composition (in molar fractions) of the</span>
<span class="sd">    simplex by averaging the molar fractions of its vertices.</span>

<span class="sd">    :return:</span>
<span class="sd">        A numpy array representing the composition at the center of the</span>
<span class="sd">        simplex in molar fractions.</span>
<span class="sd">    :rtype: numpy.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">middle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points_molar_fractions</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">for</span> <span class="n">mfr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">points_molar_fractions</span><span class="p">:</span>
      <span class="n">middle</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="n">mfr</span>

    <span class="k">return</span> <span class="n">middle</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points_molar_fractions</span><span class="p">)</span></div>
</div>

  
  
<div class="viewcode-block" id="MiscibilityAnalysis">
<a class="viewcode-back" href="../../../../picmol.models.cem.html#picmol.models.cem.lle.MiscibilityAnalysis">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MiscibilityAnalysis</span><span class="p">:</span>
<span class="w">  </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Analyzes the miscibility of a multi-component system using a point discretization.</span>

<span class="sd">  This class performs liquid-liquid equilibrium (LLE) calculations to determine</span>
<span class="sd">  the binodal curve and identify phase separation regions. It uses a</span>
<span class="sd">  discretized representation of the composition space generated by the</span>
<span class="sd">  PointDisc class.</span>

<span class="sd">  :param point_discretization:</span>
<span class="sd">      A PointDisc object representing the discretization of the</span>
<span class="sd">      composition space.</span>
<span class="sd">  :type point_discretization: PointDisc</span>
<span class="sd">  :param g_mix:</span>
<span class="sd">      An array of the Gibbs free energy of mixing</span>
<span class="sd">      as a function of composition.</span>
<span class="sd">  :type g_mix: numpy.ndarray</span>
<span class="sd">  :param activity_coefs:</span>
<span class="sd">      An array of activity coefficients of</span>
<span class="sd">      each component as a function of composition.</span>
<span class="sd">  :type activity_coefs: numpy.ndarray</span>
<span class="sd">  :param num_comp:</span>
<span class="sd">      The number of components in the system.</span>
<span class="sd">  :type num_comp: int</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">discretized_system</span><span class="p">,</span> <span class="n">g_mix</span><span class="p">,</span> <span class="n">activity_coefs</span><span class="p">,</span> <span class="n">num_comp</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">discretized_system</span> <span class="o">=</span> <span class="n">discretized_system</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">g_mix</span> <span class="o">=</span> <span class="n">g_mix</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">activity_coefs</span> <span class="o">=</span> <span class="n">activity_coefs</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">num_comp</span> <span class="o">=</span> <span class="n">num_comp</span> <span class="c1"># number of system components</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.0001</span>  <span class="c1"># for comparisons</span>

    <span class="c1"># for time stats</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">time_for_d_g_mix</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">time_for_conv_hull</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">time_for_comparisons</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># num phase stats</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">num_phase_stats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_comp</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">convex_hull_simplices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hull</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">miscibility_gap_simplices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compare_simplices</span><span class="p">()</span>

<div class="viewcode-block" id="MiscibilityAnalysis.compare_simplices">
<a class="viewcode-back" href="../../../../picmol.models.cem.html#picmol.models.cem.lle.MiscibilityAnalysis.compare_simplices">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">compare_simplices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies simplices that model phase splits within the convex hull.</span>

<span class="sd">    This method iterates through the simplices in the convex hull of the</span>
<span class="sd">    calculated graph (which includes the Gibbs free energy difference</span>
<span class="sd">    :math:`\Delta G_{mix}` as the last coordinate). It determines if each</span>
<span class="sd">    simplex connects neighboring points in the original composition space</span>
<span class="sd">    (i.e., before the addition of :math:`\Delta g_{mix}`). Simplices that do</span>
<span class="sd">    *not* connect neighboring points model a phase split.</span>

<span class="sd">    The method calculates the volume of each simplex and compares it to the</span>
<span class="sd">    expected volume of a simplex in the discretized space. It also uses</span>
<span class="sd">    the :func:`_check_simplex` method to perform</span>
<span class="sd">    the detailed analysis of each simplex.</span>

<span class="sd">    :return:</span>
<span class="sd">        A list of :class:`MiscibilityGapSimplex` objects, where each object</span>
<span class="sd">        represents a simplex that models a phase split.</span>
<span class="sd">    :rtype: list[MiscibilityGapSimplex]</span>

<span class="sd">    :ivar num_phase_stats:</span>
<span class="sd">        A list of integers, where each integer represents the count of</span>
<span class="sd">        simplices with a specific number of phases.</span>
<span class="sd">    :vartype num_phase_stats: list[int]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">miscibility_gap_simplices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">expected_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">discretized_system</span><span class="o">.</span><span class="n">stepsize</span>
    <span class="n">expected_simplex_volume</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discretized_system</span><span class="o">.</span><span class="n">volume_simplex</span><span class="p">(</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">discretized_system</span><span class="o">.</span><span class="n">vertices_outer_simplex</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
        <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">discretized_system</span><span class="o">.</span><span class="n">recursion_steps</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_comp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">simplex_points_indices</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convex_hull_simplices</span><span class="p">):</span>
      <span class="n">delta_g_s</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">simplex_points_indices</span><span class="p">]</span>
      <span class="n">real_point_indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_points_real_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">simplex_points_indices</span><span class="p">]</span>
      <span class="n">vertices_mfr</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">discretized_system</span><span class="o">.</span><span class="n">points_mfr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">real_point_indices</span><span class="p">]</span>
      <span class="n">vertices_cartesian</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">discretized_system</span><span class="o">.</span><span class="n">points_cart</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">real_point_indices</span><span class="p">]</span>
      <span class="n">simplex_volume</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discretized_system</span><span class="o">.</span><span class="n">volume_simplex</span><span class="p">(</span><span class="n">vertices_cartesian</span><span class="p">)</span>

      <span class="n">found_simplex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_simplex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_comp</span><span class="p">,</span> <span class="n">delta_g_s</span><span class="p">,</span> <span class="n">vertices_mfr</span><span class="p">,</span> <span class="n">vertices_cartesian</span><span class="p">,</span>
                         <span class="n">simplex_volume</span><span class="p">,</span> <span class="n">expected_simplex_volume</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">discretized_system</span><span class="p">,</span>
                         <span class="n">expected_length</span><span class="p">,</span> <span class="n">real_point_indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">activity_coefs</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">found_simplex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">num_phases</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">found_simplex</span><span class="o">.</span><span class="n">phase_blocks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_phase_stats</span><span class="p">[</span><span class="n">num_phases</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_phase_stats</span><span class="p">[</span><span class="n">num_phases</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">miscibility_gap_simplices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">found_simplex</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">time_for_comparisons</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

    <span class="k">return</span> <span class="n">miscibility_gap_simplices</span></div>


<div class="viewcode-block" id="MiscibilityAnalysis.get_hull">
<a class="viewcode-back" href="../../../../picmol.models.cem.html#picmol.models.cem.lle.MiscibilityAnalysis.get_hull">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">get_hull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the convex hull of the composition space, incorporating the Gibbs free energy of mixing.</span>

<span class="sd">    This method calculates the convex hull of the input data points, where each point</span>
<span class="sd">    represents a composition in the multi-component system. The input points</span>
<span class="sd">    are augmented with the Gibbs free energy of mixing (:math:`\Delta G_{mix}`)</span>
<span class="sd">    as an additional coordinate. This convex hull is used to identify regions of</span>
<span class="sd">    phase separation.</span>

<span class="sd">    The method performs the following steps:</span>

<span class="sd">    1.  Calculates :math:`\Delta G_{mix}` for each point in the discretized</span>
<span class="sd">        composition space. Positive values of :math:`\Delta G_{mix}` are</span>
<span class="sd">        clamped to zero, as they do not contribute to phase instability.</span>
<span class="sd">    2.  Constructs a graph where each node represents a composition, and the</span>
<span class="sd">        coordinates are the original Cartesian coordinates augmented with</span>
<span class="sd">        :math:`\Delta G_{mix}`.</span>
<span class="sd">    3.  Computes the convex hull of this graph.</span>

<span class="sd">    :return:</span>
<span class="sd">        A numpy array representing the simplices of the convex hull. Each</span>
<span class="sd">        simplex is defined by a set of indices into the input point set.</span>
<span class="sd">    :rtype: numpy.ndarray</span>

<span class="sd">    :ivar graph:</span>
<span class="sd">        A list (which is used like a deque) of numpy arrays.  Each array</span>
<span class="sd">        represents a point in the composition space, with the last element</span>
<span class="sd">        being the :math:`\Delta G_{mix}` value.  This is constructed by</span>
<span class="sd">        this method.</span>
<span class="sd">    :vartype graph: list[numpy.ndarray]</span>
<span class="sd">    :ivar graph_points_real_indices:</span>
<span class="sd">        A list of integers.  Each integer maps a point in the `graph` to its</span>
<span class="sd">        index in the original discretized composition space</span>
<span class="sd">        (`self.discretized_system.points_mfr` or</span>
<span class="sd">        `self.discretized_system.points_cart`).  This is constructed by</span>
<span class="sd">        this method.</span>
<span class="sd">    :vartype graph_points_real_indices: list[int]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># deque([])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">graph_points_real_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">point_mfr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">discretized_system</span><span class="o">.</span><span class="n">points_mfr</span><span class="p">):</span>
      <span class="c1"># only negative values matter for this method as positive values for delta_g_mix never</span>
      <span class="c1"># lead to a stable state</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">g_mix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g_mix</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nan</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">g_mix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_mix</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

      <span class="c1"># we only care for negative values and pure components</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_mix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">discretized_system</span><span class="o">.</span><span class="n">points_mfr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span><span class="p">:</span>
        <span class="n">graphvalue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_comp</span><span class="p">)</span>
        <span class="n">graphvalue</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discretized_system</span><span class="o">.</span><span class="n">points_cart</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">graphvalue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_mix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">graphvalue</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_points_real_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">time_for_d_g_mix</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="n">hull</span> <span class="o">=</span> <span class="n">spat</span><span class="o">.</span><span class="n">ConvexHull</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span><span class="o">.</span><span class="n">simplices</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">time_for_conv_hull</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

    <span class="k">return</span> <span class="n">hull</span></div>

  
  
<div class="viewcode-block" id="MiscibilityAnalysis.compute_phase_eq_molfrac">
<a class="viewcode-back" href="../../../../picmol.models.cem.html#picmol.models.cem.lle.MiscibilityAnalysis.compute_phase_eq_molfrac">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">compute_phase_eq_molfrac</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the phase equilibrium compositions in mole fractions.</span>

<span class="sd">    This method calculates the compositions of the two phases at equilibrium</span>
<span class="sd">    by finding points on the binodal curve. It uses the discretized</span>
<span class="sd">    composition space from the PointDisc object and the Gibbs free energy</span>
<span class="sd">    of mixing and activity coefficient arrays. The results are returned</span>
<span class="sd">    as a matrix of mol fractions.</span>

<span class="sd">    :return:</span>
<span class="sd">        A numpy array where each row represents a pair of equilibrium</span>
<span class="sd">        compositions (two phases) in mole fractions, and each column</span>
<span class="sd">        represents a component. The shape of the array is (n, 2 * num_comp),</span>
<span class="sd">        where n is the number of equilibrium pairs. If no equilibrium</span>
<span class="sd">        is found, return an empty array of shape (0, 2 * num_comp).</span>
<span class="sd">    :rtype: numpy.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">misc_gap_simpl_p_mfrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">miscibility_gap_simplices</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_comp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_comp</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">simplex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">miscibility_gap_simplices</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_comp</span><span class="p">):</span>
        <span class="n">misc_gap_simpl_p_mfrs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">simplex</span><span class="o">.</span><span class="n">points_molar_fractions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">misc_gap_simpl_p_mfrs</span></div>

  

<div class="viewcode-block" id="MiscibilityAnalysis.compute_phase_eq_cartcoord">
<a class="viewcode-back" href="../../../../picmol.models.cem.html#picmol.models.cem.lle.MiscibilityAnalysis.compute_phase_eq_cartcoord">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">compute_phase_eq_cartcoord</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the phase equilibrium compositions in Cartesian coordinates.</span>

<span class="sd">    This method calculates the compositions of the two phases at equilibrium</span>
<span class="sd">    in Cartesian coordinates, corresponding to the mol fraction</span>
<span class="sd">    compositions calculated by :func:`compute_phase_eq_molfrac`.</span>

<span class="sd">    :return:</span>
<span class="sd">        A numpy array where each row represents a pair of equilibrium</span>
<span class="sd">        compositions (two phases) in Cartesian coordinates,</span>
<span class="sd">        and each column represents a component. The shape of the array is</span>
<span class="sd">        (n, 2 * (num_comp -1)), where n is the number of equilibrium pairs.</span>
<span class="sd">        If no equilibrium is found, return an empty array of shape</span>
<span class="sd">        (0, 2 * (num_comp -1)).</span>
<span class="sd">    :rtype: numpy.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">misc_gap_simpl_p_coords_cart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">miscibility_gap_simplices</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_comp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_comp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">simplex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">miscibility_gap_simplices</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_comp</span><span class="p">):</span>
        <span class="n">misc_gap_simpl_p_coords_cart</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">simplex</span><span class="o">.</span><span class="n">points_coordinates_cart</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">misc_gap_simpl_p_coords_cart</span></div>

  

<div class="viewcode-block" id="MiscibilityAnalysis.compute_phase_eq_indices">
<a class="viewcode-back" href="../../../../picmol.models.cem.html#picmol.models.cem.lle.MiscibilityAnalysis.compute_phase_eq_indices">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">compute_phase_eq_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the indices of the phase equilibrium points.</span>

<span class="sd">    This method calculates the indices of the points in the discretized</span>
<span class="sd">    composition space that correspond to the equilibrium phase</span>
<span class="sd">    compositions. These indices can be used to retrieve the corresponding</span>
<span class="sd">    compositions from the PointDisc object&#39;s point arrays.</span>

<span class="sd">    :return:</span>
<span class="sd">        A numpy array where each row represents a pair of indices</span>
<span class="sd">        corresponding to the equilibrium phase compositions.  The shape</span>
<span class="sd">        of the array is (n, 2), where n is the number of equilibrium pairs.</span>
<span class="sd">        If no equilibrium is found, return an empty array of shape (0, 2).</span>
<span class="sd">    :rtype: numpy.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">misc_gap_simpl_p_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">miscibility_gap_simplices</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_comp</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">simplex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">miscibility_gap_simplices</span><span class="p">):</span>
      <span class="n">misc_gap_simpl_p_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">simplex</span><span class="o">.</span><span class="n">points_indices</span>

    <span class="k">return</span> <span class="n">misc_gap_simpl_p_ind</span></div>


  <span class="nd">@staticmethod</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">_check_simplex</span><span class="p">(</span><span class="n">num_comp</span><span class="p">,</span> <span class="n">delta_g_s</span><span class="p">,</span> <span class="n">vertices_mfr</span><span class="p">,</span> <span class="n">vertices_cartesian</span><span class="p">,</span> <span class="n">simplex_volume</span><span class="p">,</span> <span class="n">expected_simplex_volume</span><span class="p">,</span> <span class="n">discretized_system</span><span class="p">,</span> <span class="n">expected_length</span><span class="p">,</span> <span class="n">real_point_indices</span><span class="p">,</span> <span class="n">activity_coefs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines if a simplex represents a miscibility gap (phase split).</span>

<span class="sd">    This static method analyzes a simplex from the convex hull to determine if it</span>
<span class="sd">    represents a region of liquid-liquid phase separation (a miscibility gap).</span>
<span class="sd">    It implements the procedure described in Ryll (2009) with some modifications.</span>

<span class="sd">    The method performs several checks:</span>

<span class="sd">    1.  **Filters simplices based on :math:`\Delta g_{mix}`:** Simplices where</span>
<span class="sd">        :math:`\Delta g_{mix}` is zero for all vertices (the &quot;roof&quot; of the</span>
<span class="sd">        convex hull, consisting of pure components) are ignored.</span>
<span class="sd">    2.  **Filters simplices based on volume:** Simplices with zero volume are</span>
<span class="sd">        ignored.</span>
<span class="sd">    3.  **Compares simplex volume to expected volume:** If the simplex volume</span>
<span class="sd">        deviates significantly from the expected volume, it may indicate a</span>
<span class="sd">        miscibility gap.</span>
<span class="sd">    4.  **Checks edge lengths:** The method calculates the Euclidean distance</span>
<span class="sd">        between each pair of vertices in molar fraction space. If any edge</span>
<span class="sd">        length is significantly greater than the expected edge length, it</span>
<span class="sd">        suggests a phase split.</span>
<span class="sd">    5.  **Classifies edges:** Edges are classified as either homogeneous</span>
<span class="sd">        (connecting points within the same phase) or heterogeneous (connecting</span>
<span class="sd">        points in different phases).</span>
<span class="sd">    6.  **Identifies phase blocks:** Vertices connected only by heterogeneous</span>
<span class="sd">        edges are considered to belong to a single phase.</span>
<span class="sd">    7.  **Clusters homogeneous edges:** Homogeneous edges are grouped into</span>
<span class="sd">        clusters, and each cluster is checked to see if it forms a</span>
<span class="sd">        low-dimensional simplex. If a cluster does not form a simplex, the</span>
<span class="sd">        candidate simplex is omitted.</span>
<span class="sd">     8.  **Reduces non-ideal simplices**: Attempts to reduce non-ideal simplices.</span>

<span class="sd">    :param num_comp:</span>
<span class="sd">        The number of components in the system.</span>
<span class="sd">    :type num_comp: int</span>
<span class="sd">    :param delta_g_s:</span>
<span class="sd">        A numpy array containing the :math:`\Delta g_{mix}` values for the</span>
<span class="sd">        vertices of the simplex.</span>
<span class="sd">    :type delta_g_s: numpy.ndarray</span>
<span class="sd">    :param vertices_mfr:</span>
<span class="sd">        A list of numpy arrays, where each array represents the molar</span>
<span class="sd">        fractions of a vertex of the simplex.</span>
<span class="sd">    :type vertices_mfr: list[numpy.ndarray]</span>
<span class="sd">    :param vertices_cartesian:</span>
<span class="sd">        A list of numpy arrays, where each array represents the Cartesian</span>
<span class="sd">        coordinates of a vertex of the simplex.</span>
<span class="sd">    :type vertices_cartesian: list[numpy.ndarray]</span>
<span class="sd">    :param simplex_volume:</span>
<span class="sd">        The volume of the simplex.</span>
<span class="sd">    :type simplex_volume: float</span>
<span class="sd">    :param expected_simplex_volume:</span>
<span class="sd">        The expected volume of a simplex in the discretized composition space.</span>
<span class="sd">    :type expected_simplex_volume: float</span>
<span class="sd">    :param discretized_system:</span>
<span class="sd">        A :class:`PointDisc` object representing the discretized composition</span>
<span class="sd">        space.</span>
<span class="sd">    :type discretized_system: PointDisc</span>
<span class="sd">    :param expected_length:</span>
<span class="sd">        The expected length of an edge in the discretized composition space.</span>
<span class="sd">    :type expected_length: float</span>
<span class="sd">    :param real_point_indices:</span>
<span class="sd">        A list of integers representing the indices of the simplex vertices</span>
<span class="sd">        in the original discretized composition space.</span>
<span class="sd">    :type real_point_indices: list[int]</span>
<span class="sd">     :param activity_coefs:</span>
<span class="sd">        An array of activity coefficients of</span>
<span class="sd">        each component as a function of composition.</span>
<span class="sd">    :type activity_coefs: numpy.ndarray</span>

<span class="sd">    :return:</span>
<span class="sd">        A :class:`MiscibilityGapSimplex` object if the simplex represents a</span>
<span class="sd">        miscibility gap, otherwise None.</span>
<span class="sd">    :rtype: MiscibilityGapSimplex or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.0001</span>
    <span class="n">simplex_to_return</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># as described by Ryll 2009, we don&#39;t have to care about subsimplices, where deltag_g_mix is 0</span>
    <span class="c1"># for all vertices. this way we automatically filter the &quot;roof&quot; (consisting of the pure components</span>
    <span class="c1"># of our convex hull).</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">delta_g_s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">epsilon</span><span class="p">:</span>
      <span class="c1"># we don&#39;t care about simplices with area equal to 0</span>
      <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">simplex_volume</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="n">expected_simplex_volume</span><span class="p">:</span>
        <span class="n">matrix</span><span class="p">,</span> <span class="n">matrx_inv</span> <span class="o">=</span> <span class="n">discretized_system</span><span class="o">.</span><span class="n">get_basis_change</span><span class="p">(</span><span class="n">vertices_cartesian</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">simplex_volume</span> <span class="o">-</span> <span class="n">expected_simplex_volume</span><span class="p">)</span> <span class="o">/</span> <span class="n">expected_simplex_volume</span> <span class="o">&gt;</span> <span class="n">epsilon</span><span class="p">:</span>
          <span class="n">distance_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_comp</span><span class="p">,</span> <span class="n">num_comp</span><span class="p">))</span>
          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_comp</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_comp</span><span class="p">):</span>
              <span class="n">distance_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">discretized_system</span><span class="o">.</span><span class="n">euclidean_distance</span><span class="p">(</span><span class="n">vertices_mfr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">vertices_mfr</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
              <span class="n">distance_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

          <span class="c1"># if this is true we have a relevant simplex. we initialize a misc gap simplex</span>
          <span class="c1"># with the necessary information</span>
          <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">distance_matrix</span><span class="p">)</span> <span class="o">-</span> <span class="n">expected_length</span><span class="p">)</span> <span class="o">/</span> <span class="n">expected_length</span> <span class="o">&gt;</span> <span class="n">epsilon</span><span class="p">:</span>
            <span class="c1"># store this simplex</span>
            <span class="n">candidate_simplex</span> <span class="o">=</span> <span class="n">MiscibilityGapSimplex</span><span class="p">(</span><span class="n">vertices_cartesian</span><span class="p">,</span> <span class="n">vertices_mfr</span><span class="p">,</span> <span class="n">real_point_indices</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">matrx_inv</span><span class="p">)</span>

            <span class="c1"># we want to check if we can model the phase split in this simplex, for this, we have</span>
            <span class="c1"># to determine for each edge if it is homo- or heterogeneous</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_comp</span><span class="p">):</span>
              <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_comp</span><span class="p">):</span>
                <span class="c1"># if the edge is too long, it is heterogeneous</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">distance_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">expected_length</span><span class="p">)</span> <span class="o">/</span> <span class="n">expected_length</span> <span class="o">&gt;</span> <span class="n">epsilon</span><span class="p">:</span>
                  <span class="c1"># symmetric matrix</span>
                  <span class="n">candidate_simplex</span><span class="o">.</span><span class="n">edge_classification</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                  <span class="n">candidate_simplex</span><span class="o">.</span><span class="n">edge_classification</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">candidate_simplex</span><span class="o">.</span><span class="n">edge_classification</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="p">:</span>
              <span class="k">return</span> <span class="kc">None</span>

            <span class="c1"># we check for all vertices, if they are only connected to heterogeneous</span>
            <span class="c1"># edges (which means they represent a phase) or if there are also homogeneous</span>
            <span class="c1"># edges (and collect those to check if they form a lower dim simplex)</span>
            <span class="n">homogeneous_edges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_comp</span><span class="p">):</span>
              <span class="c1"># if all connections are heterogeneous, we have a phase</span>
              <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">candidate_simplex</span><span class="o">.</span><span class="n">edge_classification</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">0.99</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_comp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">candidate_simplex</span><span class="o">.</span><span class="n">phase_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>

              <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_comp</span><span class="p">):</span>
                  <span class="k">if</span> <span class="n">candidate_simplex</span><span class="o">.</span><span class="n">edge_classification</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="p">:</span>
                    <span class="n">homogeneous_edges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>

            <span class="c1"># now we cluster all homogeneous edges (two edges are in the same cluster,</span>
            <span class="c1"># if they have one index in common).</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cluster</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># if we add new edges to this cluster, we store a copy here, so that we check also for</span>
            <span class="c1"># those, if there are connections left in homogeneous edges</span>
            <span class="n">todo</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">homogeneous_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">todo</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
              <span class="c1"># we always compare the remaining homogeneous edges with a current edge</span>
              <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">todo</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># if empty, a new cluster is started</span>
                <span class="n">current_edge</span> <span class="o">=</span> <span class="n">homogeneous_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">homogeneous_edges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">homogeneous_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">cluster</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_edge</span><span class="p">)</span>

              <span class="k">else</span><span class="p">:</span>
                <span class="n">current_edge</span> <span class="o">=</span> <span class="n">todo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">todo</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">todo</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

              <span class="c1"># here we store the found connections</span>
              <span class="n">to_remove</span> <span class="o">=</span> <span class="p">[]</span>
              <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">homogeneous_edges</span><span class="p">):</span>
                <span class="c1"># each edge occurs only once in homogeneous edges (due to the construction)</span>
                <span class="k">if</span> <span class="n">current_edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">edge</span> <span class="ow">or</span> <span class="n">current_edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">:</span>
                  <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

              <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">:</span>
                <span class="n">cluster</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">homogeneous_edges</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">todo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">homogeneous_edges</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

              <span class="c1"># remove from homogeneous edges</span>
              <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">to_remove</span><span class="p">):</span>
                <span class="n">homogeneous_edges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">homogeneous_edges</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

              <span class="c1"># if we did not find any new edges for the cluster and do not have anything</span>
              <span class="c1"># to do, we need a new cluster</span>
              <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">todo</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
                <span class="n">cluster</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># for each cluster, we check now, if it is exactly a low-dimensional simplex (not less or</span>
            <span class="c1"># more, as then we cannot model the phase split linearly and we omit this misc gap simplex)</span>
            <span class="n">omit_candidate_simplex</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">):</span>
              <span class="c1"># it is enough to check if the cluster is a k simplex, where k+1 is the number of points</span>
              <span class="c1"># in the cluster. attention: up to now we just stored the edges of the cluster, so we have</span>
              <span class="c1"># to get the unique points first</span>
              <span class="n">point_ind_list</span> <span class="o">=</span> <span class="p">[]</span>
              <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">point_ind_list</span><span class="p">:</span>
                  <span class="n">point_ind_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">point_ind_list</span><span class="p">:</span>
                    <span class="n">point_ind_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

              <span class="c1"># now we just check for every point index, if there are exactly k edges containing this</span>
              <span class="c1"># index in the cluster (which means we would have a simplex)</span>
              <span class="k">for</span> <span class="n">point_index</span> <span class="ow">in</span> <span class="n">point_ind_list</span><span class="p">:</span>
                <span class="n">edge_count</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
                  <span class="k">if</span> <span class="n">point_index</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">:</span>
                    <span class="n">edge_count</span> <span class="o">=</span> <span class="n">edge_count</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="c1"># if this condition is not fulfilled only once, we can stop</span>
                <span class="k">if</span> <span class="n">edge_count</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">point_ind_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                  <span class="n">omit_candidate_simplex</span> <span class="o">=</span> <span class="kc">True</span>
                  <span class="k">break</span>

              <span class="c1"># we add the point list, which specifies the phase</span>
              <span class="n">candidate_simplex</span><span class="o">.</span><span class="n">phase_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point_ind_list</span><span class="p">)</span>

            <span class="c1"># sometimes we encounter non legal misc gap simplices (e.g. close to the</span>
            <span class="c1"># critical point). This means simplices, which we cannot model as for example</span>
            <span class="c1"># the phase blocks are not isolated. Here we try to reduce them, which means</span>
            <span class="c1"># we check, if some of the heterogeneous edges are homogeneous (similar as</span>
            <span class="c1"># discussed in ryll2009)and if this leads to a legal misc gap simplex.</span>
            <span class="n">reduced_simplex</span><span class="p">,</span> <span class="n">stat_std</span> <span class="o">=</span> <span class="n">MiscibilityAnalysis</span><span class="o">.</span><span class="n">_reduce_misc_gap_simplex</span><span class="p">(</span><span class="n">candidate_simplex</span><span class="p">,</span> <span class="n">activity_coefs</span><span class="p">,</span> <span class="n">discretized_system</span><span class="p">)</span>

            <span class="c1"># if no reduction is possible, add the candidate, if this does not harm the isolated</span>
            <span class="c1"># phase condition</span>
            <span class="k">if</span> <span class="n">reduced_simplex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
              <span class="k">if</span> <span class="ow">not</span> <span class="n">omit_candidate_simplex</span><span class="p">:</span>
                <span class="n">vert_num</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="n">candidate_simplex</span><span class="o">.</span><span class="n">phase_blocks</span><span class="p">:</span>
                  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">cl</span><span class="p">:</span>
                    <span class="n">vert_num</span> <span class="o">=</span> <span class="n">vert_num</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="c1"># just for safety</span>
                <span class="k">if</span> <span class="n">vert_num</span> <span class="o">!=</span> <span class="n">num_comp</span><span class="p">:</span>
                  <span class="k">return</span> <span class="mi">1</span>

                <span class="n">simplex_to_return</span> <span class="o">=</span> <span class="n">candidate_simplex</span>

            <span class="c1"># the reduced simplex fulfills the isolated phase block condition and we add this one</span>
            <span class="c1"># (if existing)</span>
            <span class="k">else</span><span class="p">:</span>
              <span class="n">simplex_to_return</span> <span class="o">=</span> <span class="n">reduced_simplex</span>

    <span class="k">return</span> <span class="n">simplex_to_return</span>
  

  <span class="nd">@staticmethod</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">_reduce_misc_gap_simplex</span><span class="p">(</span><span class="n">simplex</span><span class="p">,</span> <span class="n">activity_coefs</span><span class="p">,</span> <span class="n">discretized_system</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Attempts to reduce a miscibility gap simplex to a simpler, valid form.</span>

<span class="sd">    This static method tries to simplify a miscibility gap simplex that may be</span>
<span class="sd">    &quot;non-ideal&quot; (e.g., due to being close to a critical point) into a form that</span>
<span class="sd">    can be more accurately modeled.  The method checks if some heterogeneous</span>
<span class="sd">    edges can be reclassified as homogeneous, leading to a simpler simplex.</span>

<span class="sd">    The reduction process involves the following steps:</span>

<span class="sd">    1.  **Identify short heterogeneous edges:** Edges shorter than a threshold</span>
<span class="sd">        (0.6 times the longest heterogeneous edge) are considered candidates</span>
<span class="sd">        for reclassification.</span>
<span class="sd">    2.  **Generate edge combinations:** All possible combinations of these</span>
<span class="sd">        candidate edges are generated.</span>
<span class="sd">    3.  **Test each combination:** For each combination, a modified simplex is</span>
<span class="sd">        created where the edges in the combination are set to homogeneous.  The</span>
<span class="sd">        modified simplex is then checked for validity (i.e., if it can be modeled</span>
<span class="sd">        as a linear phase split).</span>
<span class="sd">    4.  **Select the best reduced simplex:** If multiple valid reduced simplices</span>
<span class="sd">        are found, the &quot;best&quot; one is selected based on the following criteria:</span>
<span class="sd">        -   The simplex with the fewest phase blocks is preferred.</span>
<span class="sd">        -   If multiple simplices have the same number of phase blocks, the one</span>
<span class="sd">            with the largest minimum heterogeneous edge length is preferred.</span>
<span class="sd">        -   If still not unique, the simplex with the largest average</span>
<span class="sd">            heterogeneous edge length is preferred.</span>

<span class="sd">    :param simplex:</span>
<span class="sd">        The :class:`MiscibilityGapSimplex` to be reduced.</span>
<span class="sd">    :type simplex: MiscibilityGapSimplex</span>
<span class="sd">    :param activity_coefs:</span>
<span class="sd">        An array of activity coefficients of</span>
<span class="sd">        each component as a function of composition.  This is used in the</span>
<span class="sd">        `MiscibilityAnalysis._act_mean_std_analysis` method (not shown in this</span>
<span class="sd">        code snippet).</span>
<span class="sd">    :type activity_coefs: numpy.ndarray</span>
<span class="sd">    :param discretized_system:</span>
<span class="sd">        A :class:`PointDisc` object representing the discretized composition</span>
<span class="sd">        space.</span>
<span class="sd">    :type discretized_system: PointDisc</span>

<span class="sd">    :return:</span>
<span class="sd">        A tuple containing:</span>
<span class="sd">        -   The reduced :class:`MiscibilityGapSimplex` if a valid reduction</span>
<span class="sd">            is found, otherwise None.</span>
<span class="sd">        -   A float, representing the standard deviation of some activity</span>
<span class="sd">            coefficient related value, or 0.05 if no reduction was performed.</span>
<span class="sd">    :rtype: tuple[MiscibilityGapSimplex or None, float]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">num_comp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">simplex</span><span class="o">.</span><span class="n">points_indices</span><span class="p">)</span>

    <span class="c1"># get all heterogeneous edges and the euclidean lengths</span>
    <span class="n">hetero_index_pairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">hetero_lengths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_comp</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_comp</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">simplex</span><span class="o">.</span><span class="n">edge_classification</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
          <span class="n">hetero_index_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
          <span class="n">hetero_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MiscibilityAnalysis</span><span class="o">.</span><span class="n">_distance_for_reduce</span><span class="p">(</span><span class="n">simplex</span><span class="o">.</span><span class="n">points_molar_fractions</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">simplex</span><span class="o">.</span><span class="n">points_molar_fractions</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

    <span class="n">candidate_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># if there are edges, which are quite short, we will try to reduce them.</span>
    <span class="n">max_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">hetero_lengths</span><span class="p">)</span>
    <span class="n">must_reduce</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hetero_index_pairs</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">hetero_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="n">max_len</span><span class="p">:</span>
        <span class="n">must_reduce</span> <span class="o">=</span> <span class="kc">True</span>

      <span class="n">candidate_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="n">index_subsets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">candidate_indices</span><span class="p">:</span>
      <span class="n">index_subsets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># if all indices are candidate indices, we just look at real subsets, as it just</span>
    <span class="c1"># seems quite unlikely that it is not at least some phase split there, but if there are</span>
    <span class="c1"># less candidate indices than hetero edges, we just look at all possible (sub)sets, as it</span>
    <span class="c1"># may be possible to reduce them all</span>
    <span class="n">relevant_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">hetero_index_pairs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidate_indices</span><span class="p">)])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">relevant_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">candidate_indices</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="n">index_subsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">el</span><span class="p">))</span>

    <span class="n">candidate_simplices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># for each combination of candidate indices, check if this would be a legal misc gap simplex</span>
    <span class="c1"># if the edges from the combination are set to homogeneous (so basically he same procedure as before</span>
    <span class="c1"># for the original simplex)</span>
    <span class="k">for</span> <span class="n">comb_ind</span><span class="p">,</span> <span class="n">combination</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">index_subsets</span><span class="p">):</span>
      <span class="n">candidate_simplex</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">simplex</span><span class="p">)</span>
      <span class="c1"># reset phase blocks</span>
      <span class="n">candidate_simplex</span><span class="o">.</span><span class="n">phase_blocks</span> <span class="o">=</span> <span class="p">[]</span>

      <span class="c1"># set the edges from the combination to homogeneous</span>
      <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">combination</span><span class="p">:</span>
        <span class="n">pair</span> <span class="o">=</span> <span class="n">hetero_index_pairs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">candidate_simplex</span><span class="o">.</span><span class="n">edge_classification</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">candidate_simplex</span><span class="o">.</span><span class="n">edge_classification</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>

      <span class="c1"># we check for all vertices, if they are only connected to heterogeneous</span>
      <span class="c1"># edges (which means they represent a phase) or if there are also homogeneous</span>
      <span class="c1"># edges (and collect those to check if they form a lower dim simplex)</span>
      <span class="n">homogeneous_edges</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_comp</span><span class="p">):</span>
        <span class="c1"># if all connections are heterogeneous, we have a phase</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">candidate_simplex</span><span class="o">.</span><span class="n">edge_classification</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">0.99</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_comp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
          <span class="n">candidate_simplex</span><span class="o">.</span><span class="n">phase_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
          <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_comp</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">candidate_simplex</span><span class="o">.</span><span class="n">edge_classification</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="p">:</span>
              <span class="n">homogeneous_edges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>

      <span class="c1"># now we cluster all homogeneous edges (two edges are in the same cluster,</span>
      <span class="c1"># if they have one index in common).</span>
      <span class="n">clusters</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">cluster</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="c1"># if we add new edges to this cluster, we store a copy here, so that we check also for</span>
      <span class="c1"># those, if there are connections left in homogeneous edges</span>
      <span class="n">todo</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">homogeneous_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">todo</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># we always compare the remaining homogeneous edges with a current edge</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">todo</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
          <span class="c1"># if to_do is empty, a new cluster was started</span>
          <span class="n">current_edge</span> <span class="o">=</span> <span class="n">homogeneous_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          <span class="n">homogeneous_edges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">homogeneous_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
          <span class="n">cluster</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_edge</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
          <span class="n">current_edge</span> <span class="o">=</span> <span class="n">todo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          <span class="n">todo</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">todo</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># here we store the found connections</span>
        <span class="n">to_remove</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">homogeneous_edges</span><span class="p">):</span>
          <span class="c1"># each edge occurs only once in homogeneous edges (due to the construction)</span>
          <span class="k">if</span> <span class="n">current_edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">edge</span> <span class="ow">or</span> <span class="n">current_edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">:</span>
            <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># add to cluster and to to_do</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">:</span>
          <span class="n">cluster</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">homogeneous_edges</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
          <span class="n">todo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">homogeneous_edges</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># remove from homogeneous edges</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">to_remove</span><span class="p">):</span>
          <span class="n">homogeneous_edges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">homogeneous_edges</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># if we did not find any new edges for the cluster and do not have anything in</span>
        <span class="c1"># the to_do list left, we need a new cluster</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">todo</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
          <span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
          <span class="n">cluster</span> <span class="o">=</span> <span class="p">[]</span>

      <span class="c1"># for each cluster, we check now, if it is exactly a low-dimensional simplex (not less and</span>
      <span class="c1"># more, as then we cannot model the phase split linearly and we omit this misc gap simplex)</span>
      <span class="n">omit_candidate_simplex</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">):</span>
        <span class="c1"># it is enough to check if the cluster is a k simplex, where k+1 is the number of points</span>
        <span class="c1"># in the cluster. attention: up to now we just stored the edges of the cluster, so we have</span>
        <span class="c1"># to get the unique points first</span>
        <span class="n">point_ind_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">point_ind_list</span><span class="p">:</span>
            <span class="n">point_ind_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

          <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">point_ind_list</span><span class="p">:</span>
            <span class="n">point_ind_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># now we just check for every point index, if there are exactly k edges containing this</span>
        <span class="c1"># index in the cluster (which means we would have a simplex</span>
        <span class="k">for</span> <span class="n">point_index</span> <span class="ow">in</span> <span class="n">point_ind_list</span><span class="p">:</span>
          <span class="n">edge_count</span> <span class="o">=</span> <span class="mi">0</span>
          <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">point_index</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">:</span>
              <span class="n">edge_count</span> <span class="o">=</span> <span class="n">edge_count</span> <span class="o">+</span> <span class="mi">1</span>

          <span class="c1"># if this condition is not fulfilled only once, we can stop</span>
          <span class="k">if</span> <span class="n">edge_count</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">point_ind_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">omit_candidate_simplex</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">break</span>

        <span class="c1"># we add the point list, which specifies the phase</span>
        <span class="n">candidate_simplex</span><span class="o">.</span><span class="n">phase_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point_ind_list</span><span class="p">)</span>

      <span class="c1"># if this is a split, which we can model, we add the simplex</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">omit_candidate_simplex</span><span class="p">:</span>
        <span class="n">vert_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="n">candidate_simplex</span><span class="o">.</span><span class="n">phase_blocks</span><span class="p">:</span>
          <span class="k">for</span> <span class="n">vert</span> <span class="ow">in</span> <span class="n">cl</span><span class="p">:</span>
            <span class="n">vert_num</span> <span class="o">=</span> <span class="n">vert_num</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># just for safety</span>
        <span class="k">if</span> <span class="n">vert_num</span> <span class="o">!=</span> <span class="n">num_comp</span><span class="p">:</span>
          <span class="k">return</span> <span class="mi">1</span>

        <span class="n">candidate_simplices</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">comb_ind</span><span class="p">,</span> <span class="n">combination</span><span class="p">,</span> <span class="n">candidate_simplex</span><span class="p">])</span>

    <span class="c1"># now we maybe have some candidate simplices, which are of reduced form, compared to the original simplex</span>
    <span class="n">simplex_to_return</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># get std for normal simplex, if we have _isoactivity condition, don&#39;t change it</span>
    <span class="n">std_border</span> <span class="o">=</span> <span class="mf">0.05</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">std</span> <span class="o">=</span> <span class="n">MiscibilityAnalysis</span><span class="o">.</span><span class="n">_act_mean_std_analysis</span><span class="p">(</span><span class="n">simplex</span><span class="p">,</span> <span class="n">activity_coefs</span><span class="p">,</span> <span class="n">num_comp</span><span class="p">,</span> <span class="n">discretized_system</span><span class="p">,</span> <span class="n">miscibility_gap_simplices</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">stat_to_ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">std</span><span class="p">)</span>

    <span class="c1"># we have to reduce if there was a short edge found before</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidate_simplices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">must_reduce</span> <span class="ow">or</span> <span class="n">stat_to_ret</span> <span class="o">&gt;</span> <span class="n">std_border</span><span class="p">):</span>
      <span class="c1"># if there are more candidates, we first search for the simplex with the least phase blocks</span>
      <span class="c1"># if this is not unique, we return the simplex, with the largest minimal hetero edge length</span>
      <span class="n">cand_num_phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">candidate_simplices</span><span class="p">))</span>
      <span class="n">min_hetero_edge_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">candidate_simplices</span><span class="p">))</span>
      <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">lis</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">candidate_simplices</span><span class="p">):</span>
        <span class="n">cand_num_phases</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">phase_blocks</span><span class="p">)</span>
        <span class="n">current_min</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_comp</span><span class="p">):</span>
          <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_comp</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">lis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">edge_classification</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
              <span class="n">edge_len</span> <span class="o">=</span> <span class="n">MiscibilityAnalysis</span><span class="o">.</span><span class="n">_distance_for_reduce</span><span class="p">(</span><span class="n">lis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">points_molar_fractions</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">points_molar_fractions</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

              <span class="k">if</span> <span class="n">edge_len</span> <span class="o">&lt;</span> <span class="n">current_min</span><span class="p">:</span>
                <span class="n">current_min</span> <span class="o">=</span> <span class="n">edge_len</span>

        <span class="n">min_hetero_edge_len</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_min</span>

      <span class="n">min_phases</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cand_num_phases</span><span class="p">)</span>
      <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="n">cands_with_min_phases</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">min_phases_min_hetero_lens</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">candidate_simplices</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">min_phases</span> <span class="o">-</span> <span class="n">cand_num_phases</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">:</span>
          <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span>
          <span class="n">cands_with_min_phases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
          <span class="n">min_phases_min_hetero_lens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_hetero_edge_len</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>

      <span class="n">second_reduced_cands</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cands_with_min_phases</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">max_min_hetero_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">min_phases_min_hetero_lens</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cands_with_min_phases</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">min_phases_min_hetero_lens</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">-</span> <span class="n">max_min_hetero_len</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.0001</span><span class="p">:</span>
            <span class="n">second_reduced_cands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">second_reduced_cands</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
          <span class="n">simplex_to_return</span> <span class="o">=</span> <span class="n">second_reduced_cands</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
          <span class="c1"># if this still is not enough, we check for the highest average len</span>
          <span class="c1"># in the hetero edges</span>
          <span class="n">averages</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">second_reduced_cands</span><span class="p">))</span>
          <span class="k">for</span> <span class="n">c_ind</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">second_reduced_cands</span><span class="p">):</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">iw</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">edge_classification</span><span class="p">)):</span>
              <span class="k">for</span> <span class="n">jw</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iw</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">edge_classification</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">edge_classification</span><span class="p">[</span><span class="n">iw</span><span class="p">][</span><span class="n">jw</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                  <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span>
                  <span class="n">averages</span><span class="p">[</span><span class="n">c_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">averages</span><span class="p">[</span><span class="n">c_ind</span><span class="p">]</span> <span class="o">+</span> <span class="n">MiscibilityAnalysis</span><span class="o">.</span><span class="n">_distance_for_reduce</span><span class="p">(</span>
                    <span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">points_molar_fractions</span><span class="p">[</span><span class="n">iw</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">points_molar_fractions</span><span class="p">[</span><span class="n">jw</span><span class="p">])</span>

            <span class="n">averages</span><span class="p">[</span><span class="n">c_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">averages</span><span class="p">[</span><span class="n">c_ind</span><span class="p">]</span> <span class="o">/</span> <span class="n">counter</span>

          <span class="n">simplex_to_return</span> <span class="o">=</span> <span class="n">second_reduced_cands</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">averages</span><span class="p">)][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

      <span class="k">else</span><span class="p">:</span>
        <span class="n">simplex_to_return</span> <span class="o">=</span> <span class="n">cands_with_min_phases</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">simplex_to_return</span><span class="p">,</span> <span class="n">stat_to_ret</span>


  <span class="nd">@staticmethod</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">_act_mean_std_analysis</span><span class="p">(</span><span class="n">simplex</span><span class="p">,</span> <span class="n">activity_coefs</span><span class="p">,</span> <span class="n">num_comp</span><span class="p">,</span> <span class="n">discretized_system</span><span class="p">,</span> <span class="n">miscibility_gap_simplices</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Analyzes the phase split within a miscibility gap simplex for _isoactivity.</span>

<span class="sd">    This static method calculates the mean and standard deviation of activity</span>
<span class="sd">    products (activity coefficient times molar fraction) for each component</span>
<span class="sd">    across the phases resulting from a phase split.  It uses the simplex&#39;s</span>
<span class="sd">    midpoint as the feed composition.  If a component is not present in a</span>
<span class="sd">    phase (its molar fraction is below a threshold), that phase is excluded</span>
<span class="sd">    from the analysis for that component.</span>

<span class="sd">    :param simplex:</span>
<span class="sd">        A :class:`MiscibilityGapSimplex` object representing the miscibility</span>
<span class="sd">        gap.</span>
<span class="sd">    :type simplex: MiscibilityGapSimplex</span>
<span class="sd">    :param activity_coefs:</span>
<span class="sd">        An array of activity coefficients of</span>
<span class="sd">        each component as a function of composition. This is used in the</span>
<span class="sd">        `MiscibilityAnalysis._isoactivity` method.</span>
<span class="sd">    :type activity_coefs: numpy.ndarray</span>
<span class="sd">    :param num_comp:</span>
<span class="sd">        The number of components in the system.</span>
<span class="sd">    :type num_comp: int</span>
<span class="sd">    :param discretized_system:</span>
<span class="sd">        A :class:`PointDisc` object representing the discretized composition</span>
<span class="sd">        space. This is used in the `MiscibilityAnalysis._find_phase_split`</span>
<span class="sd">        method.</span>
<span class="sd">    :type discretized_system: PointDisc</span>
<span class="sd">     :param miscibility_gap_simplices:</span>
<span class="sd">        A list of other :class:`MiscibilityGapSimplex` objects.  This is used</span>
<span class="sd">        in the `MiscibilityAnalysis._find_phase_split` method.</span>
<span class="sd">    :type miscibility_gap_simplices: list[MiscibilityGapSimplex]</span>

<span class="sd">    :return:</span>
<span class="sd">        A tuple containing:</span>
<span class="sd">        -   A numpy array of the mean activity products for each component.</span>
<span class="sd">        -   A numpy array of the standard deviations of the activity</span>
<span class="sd">            products for each component.</span>
<span class="sd">    :rtype: tuple[numpy.ndarray, numpy.ndarray]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get middle feed</span>
    <span class="n">feed_middle</span> <span class="o">=</span> <span class="n">simplex</span><span class="o">.</span><span class="n">get_middle</span><span class="p">()</span>
    <span class="n">phases_flowrates</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">MiscibilityAnalysis</span><span class="o">.</span><span class="n">_find_phase_split</span><span class="p">(</span><span class="n">feed_middle</span><span class="p">,</span> <span class="n">simplex</span><span class="p">,</span> <span class="n">discretized_system</span><span class="p">,</span> <span class="n">miscibility_gap_simplices</span><span class="p">,</span> <span class="n">num_comp</span><span class="p">)</span>

    <span class="c1"># conversion to molar fractions</span>
    <span class="n">phases_mfr</span> <span class="o">=</span> <span class="p">[</span><span class="n">fr</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fr</span><span class="p">)</span> <span class="k">for</span> <span class="n">fr</span> <span class="ow">in</span> <span class="n">phases_flowrates</span><span class="p">]</span>

    <span class="c1"># get activity coefficients and activities</span>
    <span class="n">act</span><span class="p">,</span> <span class="n">act_x_mfr</span> <span class="o">=</span> <span class="n">MiscibilityAnalysis</span><span class="o">.</span><span class="n">_isoactivity</span><span class="p">(</span><span class="n">activity_coefs</span><span class="p">,</span> <span class="n">phases_mfr</span><span class="p">)</span>

    <span class="n">border_to_be_present</span> <span class="o">=</span> <span class="mf">0.003</span>

    <span class="c1"># get mean in every index</span>
    <span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_comp</span><span class="p">)</span>
    <span class="n">counters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_comp</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mfr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">phases_mfr</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_comp</span><span class="p">):</span>
        <span class="c1"># check if component i is present</span>
        <span class="k">if</span> <span class="n">mfr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">border_to_be_present</span><span class="p">:</span>
          <span class="n">counters</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">counters</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
          <span class="n">means</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">means</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">act_x_mfr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_comp</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">counters</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">means</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">means</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">counters</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

    <span class="c1"># get std in every index</span>
    <span class="n">stds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_comp</span><span class="p">)</span>
    <span class="n">counters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_comp</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mfr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">phases_mfr</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_comp</span><span class="p">):</span>
        <span class="c1"># check if component i is present</span>
        <span class="k">if</span> <span class="n">mfr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">border_to_be_present</span><span class="p">:</span>
          <span class="n">stds</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">stds</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">act_x_mfr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">means</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
          <span class="n">counters</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">counters</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_comp</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">counters</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">stds</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">stds</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">counters</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">stds</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">stds</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">means</span><span class="p">,</span> <span class="n">stds</span>


  <span class="nd">@staticmethod</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">_find_phase_split</span><span class="p">(</span><span class="n">feed_molar_flowrates</span><span class="p">,</span> <span class="n">relevant_simplex</span><span class="p">,</span> <span class="n">discretized_system</span><span class="p">,</span> <span class="n">miscibility_gap_simplices</span><span class="p">,</span> <span class="n">num_comp</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the molar flow rates of the phases resulting from a phase split.</span>

<span class="sd">    This static method determines how an input feed stream splits into multiple</span>
<span class="sd">    phases within a miscibility gap.  It uses the provided miscibility gap</span>
<span class="sd">    simplex and discretized system information to perform this calculation.</span>

<span class="sd">    :param feed_molar_flowrates:</span>
<span class="sd">        A numpy array representing the molar flow rates of the feed stream.</span>
<span class="sd">    :type feed_molar_flowrates: numpy.ndarray</span>
<span class="sd">    :param relevant_simplex:</span>
<span class="sd">        The :class:`MiscibilityGapSimplex` object that contains the feed</span>
<span class="sd">        composition.  If None, the method attempts to find the containing</span>
<span class="sd">        simplex within `miscibility_gap_simplices`.</span>
<span class="sd">    :type relevant_simplex: MiscibilityGapSimplex or None</span>
<span class="sd">    :param discretized_system:</span>
<span class="sd">        A :class:`PointDisc` object representing the discretized composition</span>
<span class="sd">        space.  This is used for coordinate transformations.</span>
<span class="sd">    :type discretized_system: PointDisc</span>
<span class="sd">    :param miscibility_gap_simplices:</span>
<span class="sd">        A list of :class:`MiscibilityGapSimplex` objects representing all</span>
<span class="sd">        identified miscibility gaps.  This is used to find the</span>
<span class="sd">        `relevant_simplex` if it is not provided.</span>
<span class="sd">    :type miscibility_gap_simplices: list[MiscibilityGapSimplex]</span>
<span class="sd">    :param num_comp:</span>
<span class="sd">        The number of components in the system.</span>
<span class="sd">    :type num_comp: int</span>

<span class="sd">    :return:</span>
<span class="sd">        A tuple containing:</span>
<span class="sd">        -   A list of numpy arrays, where each array represents the molar</span>
<span class="sd">            flow rates of a single phase.</span>
<span class="sd">        -   The :class:`MiscibilityGapSimplex` object used for the calculation.</span>
<span class="sd">    :rtype: tuple[list[numpy.ndarray], MiscibilityGapSimplex]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># ensure non negative flowrates</span>
    <span class="n">feed_molar_flowrates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">feed_molar_flowrates</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">feed_molar_flowrates</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">feed_molar_fractions</span> <span class="o">=</span> <span class="n">feed_molar_flowrates</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">feed_molar_flowrates</span><span class="p">)</span>
      <span class="c1"># check if it is contained in a simplex with a phase split</span>
      <span class="n">feed_cartesian</span> <span class="o">=</span> <span class="n">discretized_system</span><span class="o">.</span><span class="n">transform_molar_fr_to_cartesian</span><span class="p">(</span><span class="n">feed_molar_fractions</span><span class="p">)</span>

      <span class="c1"># if the relevant simplex is not already given, try to find it</span>
      <span class="k">if</span> <span class="n">relevant_simplex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">in_gap</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">simplex_ind</span><span class="p">,</span> <span class="n">simplex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">miscibility_gap_simplices</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">MiscibilityAnalysis</span><span class="o">.</span><span class="n">point_in_simplex_via_bary</span><span class="p">(</span><span class="n">simplex</span><span class="p">,</span> <span class="n">feed_cartesian</span><span class="p">):</span>
            <span class="n">in_gap</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">relevant_simplex</span> <span class="o">=</span> <span class="n">miscibility_gap_simplices</span><span class="p">[</span><span class="n">simplex_ind</span><span class="p">]</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_gap</span><span class="p">:</span>
          <span class="k">return</span> <span class="p">[</span><span class="n">feed_molar_flowrates</span><span class="p">],</span> <span class="n">relevant_simplex</span>

      <span class="c1"># we get the barycentric coordinates of our feed with respect to the relevant simplex</span>
      <span class="n">ext_feed_cartesian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_comp</span><span class="p">)</span>
      <span class="n">ext_feed_cartesian</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">feed_cartesian</span>
      <span class="n">bary_feed_rel_simplex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">relevant_simplex</span><span class="o">.</span><span class="n">matrix_inv</span><span class="p">,</span> <span class="n">ext_feed_cartesian</span><span class="p">)</span>

      <span class="c1"># the split ratios are the sum of the barycentric coordinates of the points, which</span>
      <span class="c1"># belong to the respective phase block</span>
      <span class="n">num_phases</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">relevant_simplex</span><span class="o">.</span><span class="n">phase_blocks</span><span class="p">)</span>
      <span class="n">split_ratios</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_phases</span><span class="p">)</span>

      <span class="c1"># this way we get the split ratios and with those, we can compute the mfrs of the</span>
      <span class="c1"># phases. if we have those, we can get the flowrates.</span>
      <span class="n">mfr_phases</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">relevant_simplex</span><span class="o">.</span><span class="n">phase_blocks</span><span class="p">):</span>
        <span class="n">split_ratios</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">bary_feed_rel_simplex</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">block</span><span class="p">])</span>
        <span class="n">phase_cart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_comp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="p">)):</span>
          <span class="n">phase_cart</span> <span class="o">=</span> <span class="n">phase_cart</span> <span class="o">+</span> <span class="p">((</span><span class="n">bary_feed_rel_simplex</span><span class="p">[</span><span class="n">block</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">/</span> <span class="n">split_ratios</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">relevant_simplex</span><span class="o">.</span><span class="n">points_coordinates_cart</span><span class="p">[</span><span class="n">block</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>

        <span class="n">mfr_phases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">discretized_system</span><span class="o">.</span><span class="n">transform_cartesian_to_molar_fr</span><span class="p">(</span><span class="n">phase_cart</span><span class="p">))</span>

      <span class="n">splits_flowrates</span> <span class="o">=</span> <span class="n">MiscibilityAnalysis</span><span class="o">.</span><span class="n">get_split_flowrates</span><span class="p">(</span><span class="n">feed_molar_flowrates</span><span class="p">,</span> <span class="n">mfr_phases</span><span class="p">,</span> <span class="n">split_ratios</span><span class="p">)</span>

      <span class="k">return</span> <span class="n">splits_flowrates</span><span class="p">,</span> <span class="n">relevant_simplex</span>

    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># we just return the (empty feed)</span>
      <span class="k">return</span> <span class="p">[</span><span class="n">feed_molar_flowrates</span><span class="p">],</span> <span class="n">relevant_simplex</span>

<div class="viewcode-block" id="MiscibilityAnalysis.get_split_flowrates">
<a class="viewcode-back" href="../../../../picmol.models.cem.html#picmol.models.cem.lle.MiscibilityAnalysis.get_split_flowrates">[docs]</a>
  <span class="nd">@staticmethod</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">get_split_flowrates</span><span class="p">(</span><span class="n">molar_flowrates_feed</span><span class="p">,</span> <span class="n">phases_mfr</span><span class="p">,</span> <span class="n">split_ratio</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the molar flow rates of individual phases from a feed stream.</span>

<span class="sd">    This static method determines the molar flow rates of each phase resulting</span>
<span class="sd">    from a split of the feed stream, given the molar fractions of each phase</span>
<span class="sd">    and the split ratios.</span>

<span class="sd">    :param molar_flowrates_feed:</span>
<span class="sd">        A numpy array representing the molar flow rates of the feed stream.</span>
<span class="sd">    :type molar_flowrates_feed: numpy.ndarray</span>
<span class="sd">    :param phases_mfr:</span>
<span class="sd">        A list of numpy arrays, where each array represents the molar</span>
<span class="sd">        fractions of a phase. The order of phases in this list corresponds</span>
<span class="sd">        to the order of split ratios.</span>
<span class="sd">    :type phases_mfr: list[numpy.ndarray]</span>
<span class="sd">    :param split_ratio:</span>
<span class="sd">        A numpy array representing the split ratios for each phase. The</span>
<span class="sd">        split ratio of a phase is the fraction of the total feed flow rate</span>
<span class="sd">        that goes into that phase. The elements of split_ratio should be</span>
<span class="sd">        non-negative and sum to 1.</span>
<span class="sd">    :type split_ratio: numpy.ndarray</span>

<span class="sd">    :returns:</span>
<span class="sd">        A list of numpy arrays, where each array represents the molar flow</span>
<span class="sd">        rates of a single phase.  The order of phases in this list</span>
<span class="sd">        corresponds to the order in `phases_mfr` and `split_ratio`.</span>
<span class="sd">        Returns None if the calculated flow rates for the last phase</span>
<span class="sd">        are negative.</span>
<span class="sd">    :rtype: list[numpy.ndarray] or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.0001</span>
    <span class="n">split_flowrates</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">split_ratio</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
      <span class="n">flowrates_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">molar_flowrates_feed</span><span class="p">))</span>
      <span class="n">total_flowrate_phase</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">molar_flowrates_feed</span><span class="p">)</span> <span class="o">*</span> <span class="n">split_ratio</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">molar_flowrates_feed</span><span class="p">)):</span>
        <span class="n">flowrates_phase</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_flowrate_phase</span> <span class="o">*</span> <span class="n">phases_mfr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

      <span class="n">split_flowrates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flowrates_phase</span><span class="p">)</span>

    <span class="c1"># set the last phase</span>
    <span class="n">last_phase_flowrates</span> <span class="o">=</span> <span class="n">molar_flowrates_feed</span>
    <span class="k">for</span> <span class="n">fr</span> <span class="ow">in</span> <span class="n">split_flowrates</span><span class="p">:</span>
      <span class="n">last_phase_flowrates</span> <span class="o">=</span> <span class="n">last_phase_flowrates</span> <span class="o">-</span> <span class="n">fr</span>

    <span class="c1"># check for safety</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">last_phase_flowrates</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">molar_flowrates_feed</span><span class="p">):</span>
      <span class="c1"># print(molar_flowrates_feed, split_flowrates, last_phase_flowrates)</span>
      <span class="k">return</span> <span class="kc">None</span>

    <span class="n">split_flowrates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_phase_flowrates</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">split_flowrates</span></div>


<div class="viewcode-block" id="MiscibilityAnalysis.point_in_simplex_via_bary">
<a class="viewcode-back" href="../../../../picmol.models.cem.html#picmol.models.cem.lle.MiscibilityAnalysis.point_in_simplex_via_bary">[docs]</a>
  <span class="nd">@staticmethod</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">point_in_simplex_via_bary</span><span class="p">(</span><span class="n">simplex</span><span class="p">,</span> <span class="n">point_cartesian</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines if a point is within a simplex using barycentric coordinates.</span>

<span class="sd">    This static method calculates the barycentric coordinates of a given point</span>
<span class="sd">    with respect to a simplex.  It then checks if the barycentric coordinates</span>
<span class="sd">    are within the valid range (0 to 1) to determine if the point lies within</span>
<span class="sd">    the simplex.  It assumes that the simplex object already contains the</span>
<span class="sd">    necessary transformation matrices.</span>

<span class="sd">    :param simplex:</span>
<span class="sd">        A :class:`Simplex` object (or an object with similar attributes)</span>
<span class="sd">        containing the inverse of the matrix that transforms Cartesian</span>
<span class="sd">        coordinates to barycentric coordinates.  This object is assumed to</span>
<span class="sd">        have an attribute `matrix_inv`.</span>
<span class="sd">    :type simplex: object</span>
<span class="sd">    :param point_cartesian:</span>
<span class="sd">        A numpy array representing the Cartesian coordinates of the point</span>
<span class="sd">        to be checked.</span>
<span class="sd">    :type point_cartesian: numpy.ndarray</span>

<span class="sd">    :returns:</span>
<span class="sd">        True if the point is within the simplex, False if the point is</span>
<span class="sd">        outside the simplex, and None if the sum of the barycentric</span>
<span class="sd">        coordinates is not approximately 1 (which should not occur in a</span>
<span class="sd">        correctly formed simplex).</span>
<span class="sd">    :rtype: bool or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.0001</span>
    <span class="n">bary_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">simplex</span><span class="o">.</span><span class="n">matrix_inv</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">point_cartesian</span><span class="p">)))</span>

    <span class="c1"># this should never happen</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">bary_coords</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">epsilon</span><span class="p">:</span>
      <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># check if all coords are in the interval [0, 1]</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">bary_coords</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">epsilon</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">bary_coords</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">:</span>
      <span class="k">return</span> <span class="kc">False</span>

    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="kc">True</span></div>


  <span class="nd">@staticmethod</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">_isoactivity</span><span class="p">(</span><span class="n">activity_coefs</span><span class="p">,</span> <span class="n">mfr_list</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates activities and activity products.</span>

<span class="sd">    This static method calculates the activities and the product of activity</span>
<span class="sd">    coefficients and molar fractions for each component in each phase.  It</span>
<span class="sd">    excludes components with molar fractions close to 0 or 1 (specifically,</span>
<span class="sd">    outside the range (0.001, 0.999)).</span>

<span class="sd">    :param activity_coefs:</span>
<span class="sd">        A 2D numpy array containing the activity coefficients.</span>
<span class="sd">        `activity_coefs[i][j]` is the activity coefficient of component j in</span>
<span class="sd">        phase i.</span>
<span class="sd">    :type activity_coefs: numpy.ndarray</span>
<span class="sd">    :param mfr_list:</span>
<span class="sd">        A list of numpy arrays, where each array represents the molar</span>
<span class="sd">        fractions of a phase. `mfr_list[i][j]` is the molar fraction of</span>
<span class="sd">        component j in phase i.</span>
<span class="sd">    :type mfr_list: list[numpy.ndarray]</span>

<span class="sd">    :returns:</span>
<span class="sd">        A tuple containing two 2D numpy arrays:</span>
<span class="sd">        -   The first array contains the activities. `activities[i][j]` is the</span>
<span class="sd">            activity of component j in phase i.</span>
<span class="sd">        -   The second array contains the product of activities and molar</span>
<span class="sd">            fractions. `act_x_mfr[i][j]` is the product of the activity</span>
<span class="sd">            coefficient and molar fraction of component j in phase i.</span>
<span class="sd">            Components with molar fractions outside the range (0.001, 0.999)</span>
<span class="sd">            will have activities and activity products of 0.</span>
<span class="sd">    :rtype: tuple[numpy.ndarray, numpy.ndarray]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">activities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">mfr_list</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">mfr_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
    <span class="n">act_x_mfr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">mfr_list</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">mfr_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mfr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mfr_list</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mfr</span><span class="p">)):</span>
        <span class="k">if</span> <span class="mf">0.999</span> <span class="o">&gt;</span> <span class="n">mfr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.001</span><span class="p">:</span>
          <span class="n">activities</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">activity_coefs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
          <span class="n">act_x_mfr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">activities</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">mfr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">activities</span><span class="p">,</span> <span class="n">act_x_mfr</span>

  <span class="nd">@staticmethod</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">_distance_for_reduce</span><span class="p">(</span><span class="n">p_1_mfr</span><span class="p">,</span> <span class="n">p_2_mfr</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the Euclidean distance between two points in molar fraction space.</span>

<span class="sd">    This static method calculates the Euclidean distance between two points,</span>
<span class="sd">    where each point is represented by an array of molar fractions.</span>

<span class="sd">    :param p_1_mfr:</span>
<span class="sd">        A numpy array representing the molar fractions of the first point.</span>
<span class="sd">    :type p_1_mfr: numpy.ndarray</span>
<span class="sd">    :param p_2_mfr:</span>
<span class="sd">        A numpy array representing the molar fractions of the second point.</span>
<span class="sd">    :type p_2_mfr: numpy.ndarray</span>

<span class="sd">    :returns:</span>
<span class="sd">        The Euclidean distance between the two points.</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">p_1_mfr</span> <span class="o">-</span> <span class="n">p_2_mfr</span><span class="p">)))</span></div>

</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2025, Allison A. Peroutka
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              <a class="muted-link " href="https://github.com/aperoutka/picmol/" aria-label="GitHub"></a>
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../../../_static/documentation_options.js?v=f539c95a"></script>
    <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/scripts/furo.js?v=5fa4622c"></script>
    <script src="../../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../../_static/copybutton.js?v=f281be69"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    </body>
</html>