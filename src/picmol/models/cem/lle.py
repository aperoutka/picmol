import numpy as np
import scipy.spatial as spat
import time
import itertools
import copy

class MiscibilityGapSimplex:
  r"""
  Stores a simplex containing points that split into multiple liquid phases.

  This class represents a simplex in the composition space where liquid-liquid
  phase separation occurs. It stores the geometric and compositional
  information of the simplex, along with data about the phase split. This allows
  the class to be used to define a unit operation.

  A simplex of dimension n has N, (n + 1), vertices. Edges are classified as
  homogeneous (between neighboring points) or heterogeneous (between
  non-neighboring points, indicating a phase split). "Neighboring points"
  are defined as two points contained within the same subsimplex from the
  discretization.

  :param points_coords_cart:
      A numpy array containing the Cartesian coordinates of the simplex vertices.
  :type points_coords_cart: numpy.ndarray
  :param points_mfr:
      A numpy array containing the molar fractions of
      the simplex vertices. 
  :type points_mfr: numpy.ndarray
  :param points_ind:
      A numpy array containing the indices of the simplex vertices within the
      original discretization. 
  :type points_ind: numpy.ndarray
  :param matrix:
      A matrix used to transform molar fractions to
      a combined vector of ones and cartesian coordinates.
  :type matrix: numpy.ndarray
  :param matrix_inv:
      The inverse of the `matrix`.  
  :type matrix_inv: numpy.ndarray

  :ivar index:
      An optional index for this simplex. Defaults to None.
  :vartype index: int, optional
  :ivar points_coordinates_cart:
      The Cartesian coordinates of the simplex vertices.
  :vartype points_coordinates_cart: numpy.ndarray
  :ivar points_molar_fractions:
      The molar fractions of the simplex vertices.
  :vartype points_molar_fractions: numpy.ndarray
  :ivar points_indices:
      The indices of the simplex vertices in the original discretization.
  :vartype points_indices: numpy.ndarray
  :ivar matrix:
      The transformation matrix from molar fractions to Cartesian coordinates.
  :vartype matrix: numpy.ndarray
  :ivar matrix_inv:
      The inverse of the transformation matrix.
  :vartype matrix_inv: numpy.ndarray
  :ivar edge_classification:
      A symmetric N x N matrix. Element of :math:`i` and :math:`i` with value of 1 indicates
      that the edge between vertex :math:`i` and vertex :math:`j` is heterogeneous
      (i.e., the points are in different phases). Initialized to a matrix of
      zeros (all edges homogeneous).
  :vartype edge_classification: numpy.ndarray
  :ivar phase_blocks:
      A list of lists. Each inner list contains the indices (0 to N-1) of
      the vertices that form the basis of a single liquid phase. The order
      of phases in this list is fixed.
  :vartype phase_blocks: list[list[int]]
  """
  def __init__(self, points_coords_cart, points_mfr, points_ind, matrix, matrix_inv):
    
    self.index = None
    self.points_coordinates_cart = points_coords_cart
    self.points_molar_fractions = points_mfr
    self.points_indices = points_ind  # point indices from the simplex discretization
    self.matrix = matrix  # matrix * lambda = (1, p), lambda barycentric coordinates
    self.matrix_inv = matrix_inv

    # symmetric N x N matrix, entry[i][j] == 1 means that the edge from point[i] to point [j]
    # is heterogeneous, matrix is filled afterwards (default is a homogeneous simplex without
    # an occurring phase split).
    self.edge_classification = np.zeros((len(self.points_indices), len(self.points_indices)))

    # for each phase, we append an block = [indices], where indices refers to the point indices
    # which form the basis of the respective phase. the order here is the fixed order of the phases
    self.phase_blocks = []  # the indices in here range from 0 to N-1

  def _get_middle(self):
    r"""
    Calculates the composition at the center of the simplex. Computes the average composition (in molar fractions) of the
    simplex by averaging the molar fractions of its vertices.

    :return:
        A numpy array representing the composition at the center of the
        simplex in molar fractions.
    :rtype: numpy.ndarray
    """
    middle = np.zeros(len(self.points_molar_fractions[0]))
    for mfr in self.points_molar_fractions:
      middle = middle + mfr

    return middle / len(self.points_molar_fractions)
  
  
class MiscibilityAnalysis:
  r"""
  Analyzes the miscibility of a multi-component system using a point discretization.

  This class performs liquid-liquid equilibrium (LLE) calculations to determine
  the binodal curve and identify phase separation regions. It uses a
  discretized representation of the composition space generated by the
  :class:`PointDisc` class.

  :param point_discretization:
      A PointDisc object representing the discretization of the
      composition space.
  :type point_discretization: PointDisc
  :param g_mix:
      An array of the Gibbs free energy of mixing
      as a function of composition.
  :type g_mix: numpy.ndarray
  :param activity_coefs:
      An array of activity coefficients of
      each component as a function of composition.
  :type activity_coefs: numpy.ndarray
  :param num_comp:
      The number of components in the system.
  :type num_comp: int
  """
  def __init__(self, discretized_system, g_mix, activity_coefs, num_comp):
    self.discretized_system = discretized_system

    self.g_mix = g_mix
    self.activity_coefs = activity_coefs

    self.num_comp = num_comp # number of system components
    self.epsilon = 0.0001  # for comparisons

    # for time stats
    self.time_for_d_g_mix = None
    self.time_for_conv_hull = None
    self.time_for_comparisons = None

    # num phase stats
    self.num_phase_stats = np.zeros(self.num_comp)

    self.convex_hull_simplices = self.get_hull()
    self.miscibility_gap_simplices = self.compare_simplices()

  def compare_simplices(self):
    r"""
    Identifies simplices that model phase splits within the convex hull.

    This method iterates through the simplices in the convex hull of the
    calculated graph (which includes the Gibbs free energy difference
    :math:`\Delta G_{mix}` as the last coordinate). It determines if each
    simplex connects neighboring points in the original composition space
    (i.e., before the addition of :math:`\Delta G_{mix}`). Simplices that do
    *not* connect neighboring points model a phase split.

    :return:
        A list of :class:`MiscibilityGapSimplex` objects, where each object
        represents a simplex that models a phase split.
    :rtype: list[MiscibilityGapSimplex]

    :ivar num_phase_stats:
        A list of integers, where each integer represents the count of
        simplices with a specific number of phases.
    :vartype num_phase_stats: list[int]
    """
    miscibility_gap_simplices = []
    expected_length = np.sqrt(2) * self.discretized_system.stepsize
    expected_simplex_volume = self.discretized_system.volume_simplex(
      self.discretized_system.vertices_outer_simplex) / (
        int(2 ** self.discretized_system.recursion_steps) ** (self.num_comp - 1))

    start = time.perf_counter()
    for index, simplex_points_indices in enumerate(self.convex_hull_simplices):
      delta_g_s = [self.graph[i][-1] for i in simplex_points_indices]
      real_point_indices = [self.graph_points_real_indices[i] for i in simplex_points_indices]
      vertices_mfr = [self.discretized_system.points_mfr[i] for i in real_point_indices]
      vertices_cartesian = [self.discretized_system.points_cart[i] for i in real_point_indices]
      simplex_volume = self.discretized_system.volume_simplex(vertices_cartesian)

      found_simplex = self._check_simplex(self.num_comp, delta_g_s, vertices_mfr, vertices_cartesian,
                         simplex_volume, expected_simplex_volume, self.discretized_system,
                         expected_length, real_point_indices, self.activity_coefs)

      if found_simplex is not None:
        num_phases = len(found_simplex.phase_blocks)
        self.num_phase_stats[num_phases-1] = self.num_phase_stats[num_phases-1] + 1
        miscibility_gap_simplices.append(found_simplex)

    self.time_for_comparisons = time.perf_counter() - start

    return miscibility_gap_simplices

  def get_hull(self):
    r"""
    Computes the convex hull of the composition space, incorporating the Gibbs free energy of mixing.

    This method calculates the convex hull of the input data points, where each point
    represents a composition in the multi-component system. The input points
    are augmented with the Gibbs free energy of mixing (:math:`\Delta G_{mix}`)
    as an additional coordinate. This convex hull is used to identify regions of
    phase separation.

    :return:
        A numpy array representing the simplices of the convex hull. Each
        simplex is defined by a set of indices into the input point set.
    :rtype: numpy.ndarray

    :ivar graph:
        A list of numpy arrays, where each array
        represents a point in the composition space, with the last element
        being the :math:`\Delta G_{mix}` value. 
    :vartype graph: list[numpy.ndarray]
    :ivar graph_points_real_indices:
        A list of integers, where each integer maps a point in the ``graph`` to its
        index in the original discretized composition space
        (``PointDisc.points_mfr`` or ``PointDisc.points_cart``).
    :vartype graph_points_real_indices: list[int]
    """
    self.graph = []  # deque([])
    self.graph_points_real_indices = []
    start = time.perf_counter()
    for i, point_mfr in enumerate(self.discretized_system.points_mfr):
      # only negative values matter for this method as positive values for delta_g_mix never
      # lead to a stable state
      self.g_mix[i] = np.nan_to_num(self.g_mix[i], nan=0)
      self.g_mix[i] = np.min([0, self.g_mix[i]])

      # we only care for negative values and pure components
      if self.g_mix[i] < -1 * self.epsilon or np.max(self.discretized_system.points_mfr) > 1 - self.epsilon:
        graphvalue = np.zeros(self.num_comp)
        graphvalue[:-1] = self.discretized_system.points_cart[i]
        graphvalue[-1] = self.g_mix[i]
        self.graph.append(graphvalue)
        self.graph_points_real_indices.append(i)

    self.time_for_d_g_mix = time.perf_counter() - start

    start = time.perf_counter()
    hull = spat.ConvexHull(self.graph).simplices
    self.time_for_conv_hull = time.perf_counter() - start

    return hull
  
  
  def compute_phase_eq_molfrac(self):
    r"""
    Computes the phase equilibrium compositions in mol fractions by finding points on the binodal curve.

    :return:
        A numpy array where each row represents equilibrium
        compositions in mol fractions, and each column
        represents a component.
    :rtype: numpy.ndarray
    """
    misc_gap_simpl_p_mfrs = np.empty((len(self.miscibility_gap_simplices), self.num_comp, self.num_comp))

    for i, simplex in enumerate(self.miscibility_gap_simplices):
      for j in range(self.num_comp):
        misc_gap_simpl_p_mfrs[i][j] = simplex.points_molar_fractions[j]

    return misc_gap_simpl_p_mfrs
  

  def compute_phase_eq_cartcoord(self):
    r"""
    Computes the phase equilibrium compositions in Cartesian coordinates, corresponding to the mol fraction
    compositions calculated by :func:`compute_phase_eq_molfrac`.

    :return:
        A numpy array where each row represents equilibrium
        compositions in Cartesian coordinates,
        and each column represents a component. 
    :rtype: numpy.ndarray
    """
    misc_gap_simpl_p_coords_cart = np.empty((len(self.miscibility_gap_simplices), self.num_comp, self.num_comp - 1))
    for i, simplex in enumerate(self.miscibility_gap_simplices):
      for j in range(self.num_comp):
        misc_gap_simpl_p_coords_cart[i][j] = simplex.points_coordinates_cart[j]

    return misc_gap_simpl_p_coords_cart
  

  def compute_phase_eq_indices(self):
    r"""
    Computes the indices of the phase equilibrium points in the discretized
    composition space that correspond to the equilibrium phase
    compositions. These indices can be used to retrieve the corresponding
    compositions from the :class:`PointDisc` object's point arrays.

    :return:
        A numpy array where each row represents indices
        corresponding to the equilibrium phase compositions.
    :rtype: numpy.ndarray
    """
    misc_gap_simpl_p_ind = np.empty((len(self.miscibility_gap_simplices), self.num_comp))
    for i, simplex in enumerate(self.miscibility_gap_simplices):
      misc_gap_simpl_p_ind[i] = simplex.points_indices

    return misc_gap_simpl_p_ind

  @staticmethod
  def _check_simplex(num_comp, delta_g_s, vertices_mfr, vertices_cartesian, simplex_volume, expected_simplex_volume, discretized_system, expected_length, real_point_indices, activity_coefs):
    r"""
    Determines if a simplex represents a miscibility gap (phase split).

    This static method analyzes a simplex from the convex hull to determine if it
    represents a region of liquid-liquid phase separation (a miscibility gap).
    It implements the procedure described in Ryll (2009) with some modifications.

    The method performs several checks:

    1.  **Filters simplices based on :math:`\Delta g_{mix}`:** Simplices where
        :math:`\Delta g_{mix}` is zero for all vertices (the "roof" of the
        convex hull, consisting of pure components) are ignored.
    2.  **Filters simplices based on volume:** Simplices with zero volume are
        ignored.
    3.  **Compares simplex volume to expected volume:** If the simplex volume
        deviates significantly from the expected volume, it may indicate a
        miscibility gap.
    4.  **Checks edge lengths:** The method calculates the Euclidean distance
        between each pair of vertices in molar fraction space. If any edge
        length is significantly greater than the expected edge length, it
        suggests a phase split.
    5.  **Classifies edges:** Edges are classified as either homogeneous
        (connecting points within the same phase) or heterogeneous (connecting
        points in different phases).
    6.  **Identifies phase blocks:** Vertices connected only by heterogeneous
        edges are considered to belong to a single phase.
    7.  **Clusters homogeneous edges:** Homogeneous edges are grouped into
        clusters, and each cluster is checked to see if it forms a
        low-dimensional simplex. If a cluster does not form a simplex, the
        candidate simplex is omitted.
     8.  **Reduces non-ideal simplices**: Attempts to reduce non-ideal simplices.

    :param num_comp:
        The number of components in the system.
    :type num_comp: int
    :param delta_g_s:
        A numpy array containing the :math:`\Delta g_{mix}` values for the
        vertices of the simplex.
    :type delta_g_s: numpy.ndarray
    :param vertices_mfr:
        A list of numpy arrays, where each array represents the molar
        fractions of a vertex of the simplex.
    :type vertices_mfr: list[numpy.ndarray]
    :param vertices_cartesian:
        A list of numpy arrays, where each array represents the Cartesian
        coordinates of a vertex of the simplex.
    :type vertices_cartesian: list[numpy.ndarray]
    :param simplex_volume:
        The volume of the simplex.
    :type simplex_volume: float
    :param expected_simplex_volume:
        The expected volume of a simplex in the discretized composition space.
    :type expected_simplex_volume: float
    :param discretized_system:
        A :class:`PointDisc` object representing the discretized composition
        space.
    :type discretized_system: PointDisc
    :param expected_length:
        The expected length of an edge in the discretized composition space.
    :type expected_length: float
    :param real_point_indices:
        A list of integers representing the indices of the simplex vertices
        in the original discretized composition space.
    :type real_point_indices: list[int]
     :param activity_coefs:
        An array of activity coefficients of
        each component as a function of composition.
    :type activity_coefs: numpy.ndarray

    :return:
        A :class:`MiscibilityGapSimplex` object if the simplex represents a
        miscibility gap, otherwise None.
    :rtype: MiscibilityGapSimplex or None
    """
    epsilon = 0.0001
    simplex_to_return = None
    # as described by Ryll 2009, we don't have to care about subsimplices, where deltag_g_mix is 0
    # for all vertices. this way we automatically filter the "roof" (consisting of the pure components
    # of our convex hull).
    if np.min(delta_g_s) < -1 * epsilon:
      # we don't care about simplices with area equal to 0
      if np.abs(simplex_volume) > epsilon * expected_simplex_volume:
        matrix, matrx_inv = discretized_system.get_basis_change(vertices_cartesian)

        if np.abs(simplex_volume - expected_simplex_volume) / expected_simplex_volume > epsilon:
          distance_matrix = np.zeros((num_comp, num_comp))
          for i in range(num_comp):
            for j in range(i+1, num_comp):
              distance_matrix[i][j] = discretized_system.euclidean_distance(vertices_mfr[i], vertices_mfr[j])
              distance_matrix[j][i] = distance_matrix[i][j]

          # if this is true we have a relevant simplex. we initialize a misc gap simplex
          # with the necessary information
          if np.abs(np.max(distance_matrix) - expected_length) / expected_length > epsilon:
            # store this simplex
            candidate_simplex = MiscibilityGapSimplex(vertices_cartesian, vertices_mfr, real_point_indices, matrix, matrx_inv)

            # we want to check if we can model the phase split in this simplex, for this, we have
            # to determine for each edge if it is homo- or heterogeneous
            for i in range(num_comp):
              for j in range(i+1, num_comp):
                # if the edge is too long, it is heterogeneous
                if np.abs(distance_matrix[i][j] - expected_length) / expected_length > epsilon:
                  # symmetric matrix
                  candidate_simplex.edge_classification[i][j] = 1
                  candidate_simplex.edge_classification[j][i] = 1

            if candidate_simplex.edge_classification.sum() < 0.01:
              return None

            # we check for all vertices, if they are only connected to heterogeneous
            # edges (which means they represent a phase) or if there are also homogeneous
            # edges (and collect those to check if they form a lower dim simplex)
            homogeneous_edges = []
            for i in range(num_comp):
              # if all connections are heterogeneous, we have a phase
              if sum(candidate_simplex.edge_classification[i]) > 0.99 * (num_comp - 1):
                candidate_simplex.phase_blocks.append([i])

              else:
                for j in range(i+1, num_comp):
                  if candidate_simplex.edge_classification[i][j] < 0.01:
                    homogeneous_edges.append([i, j])

            # now we cluster all homogeneous edges (two edges are in the same cluster,
            # if they have one index in common).
            clusters = []
            cluster = []
            # if we add new edges to this cluster, we store a copy here, so that we check also for
            # those, if there are connections left in homogeneous edges
            todo = []
            while len(homogeneous_edges) > 0 or len(todo) > 0:
              # we always compare the remaining homogeneous edges with a current edge
              if len(todo) == 0:
                # if empty, a new cluster is started
                current_edge = homogeneous_edges[0]
                homogeneous_edges.remove(homogeneous_edges[0])
                cluster.append(current_edge)

              else:
                current_edge = todo[0]
                todo.remove(todo[0])

              # here we store the found connections
              to_remove = []
              for i, edge in enumerate(homogeneous_edges):
                # each edge occurs only once in homogeneous edges (due to the construction)
                if current_edge[0] in edge or current_edge[1] in edge:
                  to_remove.append(i)

              for i in to_remove:
                cluster.append(homogeneous_edges[i])
                todo.append(homogeneous_edges[i])

              # remove from homogeneous edges
              for i in reversed(to_remove):
                homogeneous_edges.remove(homogeneous_edges[i])

              # if we did not find any new edges for the cluster and do not have anything
              # to do, we need a new cluster
              if len(to_remove) == 0 and len(todo) == 0:
                clusters.append(cluster)
                cluster = []

            # for each cluster, we check now, if it is exactly a low-dimensional simplex (not less or
            # more, as then we cannot model the phase split linearly and we omit this misc gap simplex)
            omit_candidate_simplex = False
            for i, cluster in enumerate(clusters):
              # it is enough to check if the cluster is a k simplex, where k+1 is the number of points
              # in the cluster. attention: up to now we just stored the edges of the cluster, so we have
              # to get the unique points first
              point_ind_list = []
              for edge in cluster:
                if edge[0] not in point_ind_list:
                  point_ind_list.append(edge[0])

                if edge[1] not in point_ind_list:
                    point_ind_list.append(edge[1])

              # now we just check for every point index, if there are exactly k edges containing this
              # index in the cluster (which means we would have a simplex)
              for point_index in point_ind_list:
                edge_count = 0
                for edge in cluster:
                  if point_index in edge:
                    edge_count = edge_count + 1

                # if this condition is not fulfilled only once, we can stop
                if edge_count != len(point_ind_list) - 1:
                  omit_candidate_simplex = True
                  break

              # we add the point list, which specifies the phase
              candidate_simplex.phase_blocks.append(point_ind_list)

            # sometimes we encounter non legal misc gap simplices (e.g. close to the
            # critical point). This means simplices, which we cannot model as for example
            # the phase blocks are not isolated. Here we try to reduce them, which means
            # we check, if some of the heterogeneous edges are homogeneous (similar as
            # discussed in ryll2009)and if this leads to a legal misc gap simplex.
            reduced_simplex, stat_std = MiscibilityAnalysis._reduce_misc_gap_simplex(candidate_simplex, activity_coefs, discretized_system)

            # if no reduction is possible, add the candidate, if this does not harm the isolated
            # phase condition
            if reduced_simplex is None:
              if not omit_candidate_simplex:
                vert_num = 0
                for cl in candidate_simplex.phase_blocks:
                  for _ in cl:
                    vert_num = vert_num + 1

                # just for safety
                if vert_num != num_comp:
                  return 1

                simplex_to_return = candidate_simplex

            # the reduced simplex fulfills the isolated phase block condition and we add this one
            # (if existing)
            else:
              simplex_to_return = reduced_simplex

    return simplex_to_return
  

  @staticmethod
  def _reduce_misc_gap_simplex(simplex, activity_coefs, discretized_system):
    r"""
    Attempts to reduce a miscibility gap simplex to a simpler, valid form.

    This static method tries to simplify a miscibility gap simplex that may be
    "non-ideal" (e.g., due to being close to a critical point) into a form that
    can be more accurately modeled.  The method checks if some heterogeneous
    edges can be reclassified as homogeneous, leading to a simpler simplex.

    The reduction process involves the following steps:

    1.  **Identify short heterogeneous edges:** Edges shorter than a threshold
        (0.6 times the longest heterogeneous edge) are considered candidates
        for reclassification.
    2.  **Generate edge combinations:** All possible combinations of these
        candidate edges are generated.
    3.  **Test each combination:** For each combination, a modified simplex is
        created where the edges in the combination are set to homogeneous.  The
        modified simplex is then checked for validity (i.e., if it can be modeled
        as a linear phase split).
    4.  **Select the best reduced simplex:** If multiple valid reduced simplices
        are found, the "best" one is selected based on the following criteria:
        -   The simplex with the fewest phase blocks is preferred.
        -   If multiple simplices have the same number of phase blocks, the one
            with the largest minimum heterogeneous edge length is preferred.
        -   If still not unique, the simplex with the largest average
            heterogeneous edge length is preferred.

    :param simplex:
        The :class:`MiscibilityGapSimplex` to be reduced.
    :type simplex: MiscibilityGapSimplex
    :param activity_coefs:
        An array of activity coefficients of
        each component as a function of composition.  This is used in the
        `MiscibilityAnalysis._act_mean_std_analysis` method (not shown in this
        code snippet).
    :type activity_coefs: numpy.ndarray
    :param discretized_system:
        A :class:`PointDisc` object representing the discretized composition
        space.
    :type discretized_system: PointDisc

    :return:
        A tuple containing:
        -   The reduced :class:`MiscibilityGapSimplex` if a valid reduction
            is found, otherwise None.
        -   A float, representing the standard deviation of some activity
            coefficient related value, or 0.05 if no reduction was performed.
    :rtype: tuple[MiscibilityGapSimplex or None, float]
    """

    num_comp = len(simplex.points_indices)

    # get all heterogeneous edges and the euclidean lengths
    hetero_index_pairs = []
    hetero_lengths = []
    for i in range(num_comp):
      for j in range(i + 1, num_comp):
        if simplex.edge_classification[i][j] == 1:
          hetero_index_pairs.append([i, j])
          hetero_lengths.append(MiscibilityAnalysis._distance_for_reduce(simplex.points_molar_fractions[i], simplex.points_molar_fractions[j]))

    candidate_indices = []
    # if there are edges, which are quite short, we will try to reduce them.
    max_len = np.max(hetero_lengths)
    must_reduce = False
    for i, pair in enumerate(hetero_index_pairs):
      if hetero_lengths[i] < 0.6 * max_len:
        must_reduce = True

      candidate_indices.append(i)

    index_subsets = []
    for i in candidate_indices:
      index_subsets.append([i])

    # if all indices are candidate indices, we just look at real subsets, as it just
    # seems quite unlikely that it is not at least some phase split there, but if there are
    # less candidate indices than hetero edges, we just look at all possible (sub)sets, as it
    # may be possible to reduce them all
    relevant_length = np.min([len(hetero_index_pairs) - 1, len(candidate_indices)])
    for i in range(2, relevant_length + 1):
      for el in itertools.combinations(candidate_indices, i):
        index_subsets.append(list(el))

    candidate_simplices = []
    # for each combination of candidate indices, check if this would be a legal misc gap simplex
    # if the edges from the combination are set to homogeneous (so basically he same procedure as before
    # for the original simplex)
    for comb_ind, combination in enumerate(index_subsets):
      candidate_simplex = copy.deepcopy(simplex)
      # reset phase blocks
      candidate_simplex.phase_blocks = []

      # set the edges from the combination to homogeneous
      for index in combination:
        pair = hetero_index_pairs[index]
        candidate_simplex.edge_classification[pair[0]][pair[1]] = 0
        candidate_simplex.edge_classification[pair[1]][pair[0]] = 0

      # we check for all vertices, if they are only connected to heterogeneous
      # edges (which means they represent a phase) or if there are also homogeneous
      # edges (and collect those to check if they form a lower dim simplex)
      homogeneous_edges = []
      for i in range(num_comp):
        # if all connections are heterogeneous, we have a phase
        if sum(candidate_simplex.edge_classification[i]) > 0.99 * (num_comp - 1):
          candidate_simplex.phase_blocks.append([i])

        else:
          for j in range(i + 1, num_comp):
            if candidate_simplex.edge_classification[i][j] < 0.01:
              homogeneous_edges.append([i, j])

      # now we cluster all homogeneous edges (two edges are in the same cluster,
      # if they have one index in common).
      clusters = []
      cluster = []
      # if we add new edges to this cluster, we store a copy here, so that we check also for
      # those, if there are connections left in homogeneous edges
      todo = []
      while len(homogeneous_edges) > 0 or len(todo) > 0:
        # we always compare the remaining homogeneous edges with a current edge
        if len(todo) == 0:
          # if to_do is empty, a new cluster was started
          current_edge = homogeneous_edges[0]
          homogeneous_edges.remove(homogeneous_edges[0])
          cluster.append(current_edge)

        else:
          current_edge = todo[0]
          todo.remove(todo[0])

        # here we store the found connections
        to_remove = []
        for i, edge in enumerate(homogeneous_edges):
          # each edge occurs only once in homogeneous edges (due to the construction)
          if current_edge[0] in edge or current_edge[1] in edge:
            to_remove.append(i)

        # add to cluster and to to_do
        for i in to_remove:
          cluster.append(homogeneous_edges[i])
          todo.append(homogeneous_edges[i])

        # remove from homogeneous edges
        for i in reversed(to_remove):
          homogeneous_edges.remove(homogeneous_edges[i])

        # if we did not find any new edges for the cluster and do not have anything in
        # the to_do list left, we need a new cluster
        if len(to_remove) == 0 and len(todo) == 0:
          clusters.append(cluster)
          cluster = []

      # for each cluster, we check now, if it is exactly a low-dimensional simplex (not less and
      # more, as then we cannot model the phase split linearly and we omit this misc gap simplex)
      omit_candidate_simplex = False
      for i, cluster in enumerate(clusters):
        # it is enough to check if the cluster is a k simplex, where k+1 is the number of points
        # in the cluster. attention: up to now we just stored the edges of the cluster, so we have
        # to get the unique points first
        point_ind_list = []
        for edge in cluster:
          if edge[0] not in point_ind_list:
            point_ind_list.append(edge[0])

          if edge[1] not in point_ind_list:
            point_ind_list.append(edge[1])

        # now we just check for every point index, if there are exactly k edges containing this
        # index in the cluster (which means we would have a simplex
        for point_index in point_ind_list:
          edge_count = 0
          for edge in cluster:
            if point_index in edge:
              edge_count = edge_count + 1

          # if this condition is not fulfilled only once, we can stop
          if edge_count != len(point_ind_list) - 1:
            omit_candidate_simplex = True
            break

        # we add the point list, which specifies the phase
        candidate_simplex.phase_blocks.append(point_ind_list)

      # if this is a split, which we can model, we add the simplex
      if not omit_candidate_simplex:
        vert_num = 0
        for cl in candidate_simplex.phase_blocks:
          for vert in cl:
            vert_num = vert_num + 1

        # just for safety
        if vert_num != num_comp:
          return 1

        candidate_simplices.append([comb_ind, combination, candidate_simplex])

    # now we maybe have some candidate simplices, which are of reduced form, compared to the original simplex
    simplex_to_return = None
    # get std for normal simplex, if we have _isoactivity condition, don't change it
    std_border = 0.05
    _, std = MiscibilityAnalysis._act_mean_std_analysis(simplex, activity_coefs, num_comp, discretized_system, miscibility_gap_simplices=None)
    stat_to_ret = np.max(std)

    # we have to reduce if there was a short edge found before
    if len(candidate_simplices) > 0 and (must_reduce or stat_to_ret > std_border):
      # if there are more candidates, we first search for the simplex with the least phase blocks
      # if this is not unique, we return the simplex, with the largest minimal hetero edge length
      cand_num_phases = np.zeros(len(candidate_simplices))
      min_hetero_edge_len = np.zeros(len(candidate_simplices))
      for ind, lis in enumerate(candidate_simplices):
        cand_num_phases[ind] = len(lis[-1].phase_blocks)
        current_min = float('inf')
        for i in range(num_comp):
          for j in range(i + 1, num_comp):
            if lis[-1].edge_classification[i][j] == 1:
              edge_len = MiscibilityAnalysis._distance_for_reduce(lis[-1].points_molar_fractions[i], lis[-1].points_molar_fractions[j])

              if edge_len < current_min:
                current_min = edge_len

        min_hetero_edge_len[ind] = current_min

      min_phases = min(cand_num_phases)
      counter = 0
      cands_with_min_phases = []
      min_phases_min_hetero_lens = []
      for ind, c in enumerate(candidate_simplices):
        if np.abs(min_phases - cand_num_phases[ind]) < 0.1:
          counter = counter + 1
          cands_with_min_phases.append(c)
          min_phases_min_hetero_lens.append(min_hetero_edge_len[ind])

      second_reduced_cands = []
      if len(cands_with_min_phases) > 1:
        max_min_hetero_len = np.max(min_phases_min_hetero_lens)
        for ind, c in enumerate(cands_with_min_phases):
          if np.abs(min_phases_min_hetero_lens[ind] - max_min_hetero_len) < 0.0001:
            second_reduced_cands.append(c)

        if len(second_reduced_cands) <= 1:
          simplex_to_return = second_reduced_cands[0][-1]

        else:
          # if this still is not enough, we check for the highest average len
          # in the hetero edges
          averages = np.zeros(len(second_reduced_cands))
          for c_ind, c in enumerate(second_reduced_cands):
            counter = 0
            for iw in range(len(c[-1].edge_classification)):
              for jw in range(iw + 1, len(c[-1].edge_classification)):
                if c[-1].edge_classification[iw][jw] == 1:
                  counter = counter + 1
                  averages[c_ind] = averages[c_ind] + MiscibilityAnalysis._distance_for_reduce(
                    c[-1].points_molar_fractions[iw], c[-1].points_molar_fractions[jw])

            averages[c_ind] = averages[c_ind] / counter

          simplex_to_return = second_reduced_cands[np.argmax(averages)][-1]

      else:
        simplex_to_return = cands_with_min_phases[0][-1]

    return simplex_to_return, stat_to_ret


  @staticmethod
  def _act_mean_std_analysis(simplex, activity_coefs, num_comp, discretized_system, miscibility_gap_simplices):
    r"""
    Analyzes the phase split within a miscibility gap simplex for _isoactivity.

    This static method calculates the mean and standard deviation of activity
    products (activity coefficient times molar fraction) for each component
    across the phases resulting from a phase split.  It uses the simplex's
    midpoint as the feed composition.  If a component is not present in a
    phase (its molar fraction is below a threshold), that phase is excluded
    from the analysis for that component.

    :param simplex:
        A :class:`MiscibilityGapSimplex` object representing the miscibility
        gap.
    :type simplex: MiscibilityGapSimplex
    :param activity_coefs:
        An array of activity coefficients of
        each component as a function of composition. This is used in the
        `MiscibilityAnalysis._isoactivity` method.
    :type activity_coefs: numpy.ndarray
    :param num_comp:
        The number of components in the system.
    :type num_comp: int
    :param discretized_system:
        A :class:`PointDisc` object representing the discretized composition
        space. This is used in the `MiscibilityAnalysis._find_phase_split`
        method.
    :type discretized_system: PointDisc
     :param miscibility_gap_simplices:
        A list of other :class:`MiscibilityGapSimplex` objects.  This is used
        in the `MiscibilityAnalysis._find_phase_split` method.
    :type miscibility_gap_simplices: list[MiscibilityGapSimplex]

    :return:
        A tuple containing:
        -   A numpy array of the mean activity products for each component.
        -   A numpy array of the standard deviations of the activity
            products for each component.
    :rtype: tuple[numpy.ndarray, numpy.ndarray]
    """
    # get middle feed
    feed_middle = simplex._get_middle()
    phases_flowrates, _ = MiscibilityAnalysis._find_phase_split(feed_middle, simplex, discretized_system, miscibility_gap_simplices, num_comp)

    # conversion to molar fractions
    phases_mfr = [fr / sum(fr) for fr in phases_flowrates]

    # get activity coefficients and activities
    act, act_x_mfr = MiscibilityAnalysis._isoactivity(activity_coefs, phases_mfr)

    border_to_be_present = 0.003

    # get mean in every index
    means = np.zeros(num_comp)
    counters = np.zeros(num_comp)
    for i, mfr in enumerate(phases_mfr):
      for j in range(num_comp):
        # check if component i is present
        if mfr[j] > border_to_be_present:
          counters[j] = counters[j] + 1
          means[j] = means[j] + act_x_mfr[i][j]

    for j in range(num_comp):
      if counters[j] > 0:
        means[j] = means[j] / counters[j]

    # get std in every index
    stds = np.zeros(num_comp)
    counters = np.zeros(num_comp)
    for i, mfr in enumerate(phases_mfr):
      for j in range(num_comp):
        # check if component i is present
        if mfr[j] > border_to_be_present:
          stds[j] = stds[j] + np.square(act_x_mfr[i][j] - means[j])
          counters[j] = counters[j] + 1

    for j in range(num_comp):
      if counters[j] > 0:
        stds[j] = stds[j] / counters[j]
        stds[j] = np.sqrt(stds[j])

    return means, stds


  @staticmethod
  def _find_phase_split(feed_molar_flowrates, relevant_simplex, discretized_system, miscibility_gap_simplices, num_comp):
    r"""
    Calculates the molar flow rates of the phases resulting from a phase split.

    This static method determines how an input feed stream splits into multiple
    phases within a miscibility gap.  It uses the provided miscibility gap
    simplex and discretized system information to perform this calculation.

    :param feed_molar_flowrates:
        A numpy array representing the molar flow rates of the feed stream.
    :type feed_molar_flowrates: numpy.ndarray
    :param relevant_simplex:
        The :class:`MiscibilityGapSimplex` object that contains the feed
        composition.  If None, the method attempts to find the containing
        simplex within `miscibility_gap_simplices`.
    :type relevant_simplex: MiscibilityGapSimplex or None
    :param discretized_system:
        A :class:`PointDisc` object representing the discretized composition
        space.  This is used for coordinate transformations.
    :type discretized_system: PointDisc
    :param miscibility_gap_simplices:
        A list of :class:`MiscibilityGapSimplex` objects representing all
        identified miscibility gaps.  This is used to find the
        `relevant_simplex` if it is not provided.
    :type miscibility_gap_simplices: list[MiscibilityGapSimplex]
    :param num_comp:
        The number of components in the system.
    :type num_comp: int

    :return:
        A tuple containing:
        -   A list of numpy arrays, where each array represents the molar
            flow rates of a single phase.
        -   The :class:`MiscibilityGapSimplex` object used for the calculation.
    :rtype: tuple[list[numpy.ndarray], MiscibilityGapSimplex]
    """
    # ensure non negative flowrates
    feed_molar_flowrates = np.clip(feed_molar_flowrates, 0, None)
    if sum(feed_molar_flowrates) > 0:
      feed_molar_fractions = feed_molar_flowrates / sum(feed_molar_flowrates)
      # check if it is contained in a simplex with a phase split
      feed_cartesian = discretized_system.transform_molar_fr_to_cartesian(feed_molar_fractions)

      # if the relevant simplex is not already given, try to find it
      if relevant_simplex is None:
        in_gap = False
        for simplex_ind, simplex in enumerate(miscibility_gap_simplices):
          if MiscibilityAnalysis._point_in_simplex_via_bary(simplex, feed_cartesian):
            in_gap = True
            relevant_simplex = miscibility_gap_simplices[simplex_ind]
            break

        if not in_gap:
          return [feed_molar_flowrates], relevant_simplex

      # we get the barycentric coordinates of our feed with respect to the relevant simplex
      ext_feed_cartesian = np.ones(num_comp)
      ext_feed_cartesian[1:] = feed_cartesian
      bary_feed_rel_simplex = np.matmul(relevant_simplex.matrix_inv, ext_feed_cartesian)

      # the split ratios are the sum of the barycentric coordinates of the points, which
      # belong to the respective phase block
      num_phases = len(relevant_simplex.phase_blocks)
      split_ratios = np.zeros(num_phases)

      # this way we get the split ratios and with those, we can compute the mfrs of the
      # phases. if we have those, we can get the flowrates.
      mfr_phases = []
      for i, block in enumerate(relevant_simplex.phase_blocks):
        split_ratios[i] = sum([bary_feed_rel_simplex[j] for j in block])
        phase_cart = np.zeros(num_comp - 1)
        for j in range(len(block)):
          phase_cart = phase_cart + ((bary_feed_rel_simplex[block[j]] / split_ratios[i]) * relevant_simplex.points_coordinates_cart[block[j]])

        mfr_phases.append(discretized_system.transform_cartesian_to_molar_fr(phase_cart))

      splits_flowrates = MiscibilityAnalysis._get_split_flowrates(feed_molar_flowrates, mfr_phases, split_ratios)

      return splits_flowrates, relevant_simplex

    else:
      # we just return the (empty feed)
      return [feed_molar_flowrates], relevant_simplex

  @staticmethod
  def _get_split_flowrates(molar_flowrates_feed, phases_mfr, split_ratio):
    r"""
    Calculates the molar flow rates of individual phases from a feed stream.

    This static method determines the molar flow rates of each phase resulting
    from a split of the feed stream, given the molar fractions of each phase
    and the split ratios.

    :param molar_flowrates_feed:
        A numpy array representing the molar flow rates of the feed stream.
    :type molar_flowrates_feed: numpy.ndarray
    :param phases_mfr:
        A list of numpy arrays, where each array represents the molar
        fractions of a phase. The order of phases in this list corresponds
        to the order of split ratios.
    :type phases_mfr: list[numpy.ndarray]
    :param split_ratio:
        A numpy array representing the split ratios for each phase. The
        split ratio of a phase is the fraction of the total feed flow rate
        that goes into that phase. The elements of split_ratio should be
        non-negative and sum to 1.
    :type split_ratio: numpy.ndarray

    :returns:
        A list of numpy arrays, where each array represents the molar flow
        rates of a single phase.  The order of phases in this list
        corresponds to the order in `phases_mfr` and `split_ratio`.
        Returns None if the calculated flow rates for the last phase
        are negative.
    :rtype: list[numpy.ndarray] or None
    """
    epsilon = 0.0001
    split_flowrates = []
    for i in range(len(split_ratio) - 1):
      flowrates_phase = np.zeros(len(molar_flowrates_feed))
      total_flowrate_phase = sum(molar_flowrates_feed) * split_ratio[i]
      for j in range(len(molar_flowrates_feed)):
        flowrates_phase[j] = total_flowrate_phase * phases_mfr[i][j]

      split_flowrates.append(flowrates_phase)

    # set the last phase
    last_phase_flowrates = molar_flowrates_feed
    for fr in split_flowrates:
      last_phase_flowrates = last_phase_flowrates - fr

    # check for safety
    if np.min(last_phase_flowrates) < -1 * epsilon * sum(molar_flowrates_feed):
      # print(molar_flowrates_feed, split_flowrates, last_phase_flowrates)
      return None

    split_flowrates.append(last_phase_flowrates)

    return split_flowrates

  @staticmethod
  def _point_in_simplex_via_bary(simplex, point_cartesian):
    r"""
    Determines if a point is within a simplex using barycentric coordinates.

    This static method calculates the barycentric coordinates of a given point
    with respect to a simplex.  It then checks if the barycentric coordinates
    are within the valid range (0 to 1) to determine if the point lies within
    the simplex.  It assumes that the simplex object already contains the
    necessary transformation matrices.

    :param simplex:
        A :class:`Simplex` object (or an object with similar attributes)
        containing the inverse of the matrix that transforms Cartesian
        coordinates to barycentric coordinates.  This object is assumed to
        have an attribute `matrix_inv`.
    :type simplex: object
    :param point_cartesian:
        A numpy array representing the Cartesian coordinates of the point
        to be checked.
    :type point_cartesian: numpy.ndarray

    :returns:
        True if the point is within the simplex, False if the point is
        outside the simplex, and None if the sum of the barycentric
        coordinates is not approximately 1 (which should not occur in a
        correctly formed simplex).
    :rtype: bool or None
    """
    epsilon = 0.0001
    bary_coords = np.matmul(simplex.matrix_inv, np.array([1] + list(point_cartesian)))

    # this should never happen
    if np.abs(sum(bary_coords) - 1) > epsilon:
      return None

    # check if all coords are in the interval [0, 1]
    if np.min(bary_coords) < -1 * epsilon or np.max(bary_coords) > 1 + epsilon:
      return False

    else:
      return True

  @staticmethod
  def _isoactivity(activity_coefs, mfr_list):
    r"""
    Calculates activities and activity products.

    This static method calculates the activities and the product of activity
    coefficients and molar fractions for each component in each phase.  It
    excludes components with molar fractions close to 0 or 1 (specifically,
    outside the range (0.001, 0.999)).

    :param activity_coefs:
        A 2D numpy array containing the activity coefficients.
        `activity_coefs[i][j]` is the activity coefficient of component j in
        phase i.
    :type activity_coefs: numpy.ndarray
    :param mfr_list:
        A list of numpy arrays, where each array represents the molar
        fractions of a phase. `mfr_list[i][j]` is the molar fraction of
        component j in phase i.
    :type mfr_list: list[numpy.ndarray]

    :returns:
        A tuple containing two 2D numpy arrays:
        -   The first array contains the activities. `activities[i][j]` is the
            activity of component j in phase i.
        -   The second array contains the product of activities and molar
            fractions. `act_x_mfr[i][j]` is the product of the activity
            coefficient and molar fraction of component j in phase i.
            Components with molar fractions outside the range (0.001, 0.999)
            will have activities and activity products of 0.
    :rtype: tuple[numpy.ndarray, numpy.ndarray]
    """
    activities = np.zeros((len(mfr_list), len(mfr_list[0])))
    act_x_mfr = np.zeros((len(mfr_list), len(mfr_list[0])))
    for i, mfr in enumerate(mfr_list):
      for j in range(len(mfr)):
        if 0.999 > mfr[j] > 0.001:
          activities[i][j] = activity_coefs[i][j]
          act_x_mfr[i][j] = activities[i][j] * mfr[j]

    return activities, act_x_mfr

  @staticmethod
  def _distance_for_reduce(p_1_mfr, p_2_mfr):
    r"""
    Calculates the Euclidean distance between two points in molar fraction space.

    This static method calculates the Euclidean distance between two points,
    where each point is represented by an array of molar fractions.

    :param p_1_mfr:
        A numpy array representing the molar fractions of the first point.
    :type p_1_mfr: numpy.ndarray
    :param p_2_mfr:
        A numpy array representing the molar fractions of the second point.
    :type p_2_mfr: numpy.ndarray

    :returns:
        The Euclidean distance between the two points.
    :rtype: float
    """
    return np.sqrt(sum(np.square(p_1_mfr - p_2_mfr)))
